<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · Grassmann.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Grassmann.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Design</a><ul class="internal"><li><a class="tocitem" href="#Direct-sum-yields-VectorBundle-parametric-type-polymorphism-1"><span>Direct-sum yields <code>VectorBundle</code> parametric type polymorphism ⨁</span></a></li><li><a class="tocitem" href="#Interoperability-for-TensorAlgebra{V}-1"><span>Interoperability for <code>TensorAlgebra{V}</code></span></a></li></ul></li><li><a class="tocitem" href="../algebra/">Algebra</a></li><li><a class="tocitem" href="../library/">Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/quick-start/">Quick start (G2)</a></li><li><a class="tocitem" href="../tutorials/algebra-of-space/">The Algebra of Space (G3)</a></li><li><a class="tocitem" href="../tutorials/mixed-tensors/">Mixed tensor product ⊗</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Grassmann.jl/blob/master/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TensorAlgebra-design,-Manifold-code-generation-1"><a class="docs-heading-anchor" href="#TensorAlgebra-design,-Manifold-code-generation-1"><code>TensorAlgebra</code> design, <code>Manifold</code> code generation</a><a class="docs-heading-anchor-permalink" href="#TensorAlgebra-design,-Manifold-code-generation-1" title="Permalink"></a></h1><p>Mathematical foundations and definitions specific to the <a href="https://github.com/chakravala/Grassmann.jl">Grassmann.jl</a> implementation provide an extensible platform for computing with geometric algebra at high dimensions, along with the accompanying support packages.  The design is based on the <code>TensorAlgebra</code> abstract type interoperability from <a href="https://github.com/chakravala/AbstractTensors.jl">AbstractTensors.jl</a> with a <code>VectorBundle</code> parameter from <a href="https://github.com/chakravala/DirectSum.jl">DirectSum.jl</a>. Abstract tangent vector space type operations happen at compile-time, resulting in a differential conformal geometric algebra of hyper-dual multivector forms.</p><p>The nature of the geometric algebra code generation enables one to easily extend the abstract product operations to any specific number field type (including differential operators with <a href="https://github.com/chakravala/Leibniz.jl">Leibniz.jl</a> or symbolic coefficients with <a href="https://github.com/chakravala/Reduce.jl">Reduce.jl</a>), by making use of Julia&#39;s type system. Mixed tensor products with their coefficients are constructed from these operations to work with bivector elements of Lie groups.</p><ul><li><strong>DirectSum.jl</strong>: Abstract tangent bundle vector space types (unions, intersections, sums, etc.)</li><li><strong>AbstractTensors.jl</strong>: Tensor algebra abstract type interoperability with vector bundle parameter</li><li><strong>Grassmann.jl</strong>: ⟨Leibniz-Grassmann-Clifford-Hestenes⟩ differential geometric algebra of multivector forms</li><li><strong>Leibniz.jl</strong>: Derivation operator algebras for tensor fields</li><li><strong>Reduce.jl</strong>: Symbolic parser generator for Julia expressions using REDUCE algebra term rewriter</li></ul><p>Mathematics of <code>Grassmann</code> can be used to study unitary groups used in quantum computing by building efficient computational representations of their algebras. Applicability of the Grassmann computational package not only maps to quantum computing, but has the potential of impacting countless other engineering and scientific computing applications. It can be used to work with automatic differentiation and differential geometry, algebraic forms and invariant theory, electric circuits and wave scattering, spacetime geometry and relativity, computer graphics and photogrammetry, and much more.</p><p>Thus, computations involving fully general rotational algebras and Lie bivector groups are possible with a full trigonometric suite. Conformal geometric algebra is possible with the Minkowski plane <span>$v_{\infty\emptyset}$</span>, based on the null-basis. In general, multivalued quantum logic is enabled by the <span>$\wedge,\vee,\star$</span> Grassmann lattice. Mixed-symmetry algebra with <em>Leibniz.jl</em> and <em>Grassmann.jl</em>, having the geometric algebraic product chain rule, yields automatic differentiation and Hodge-DeRahm co/homology  as unveiled by Grassmann. Most importantly, the Dirac-Clifford product yields generalized Hodge-Laplacian and the Betti numbers with Euler characteristic <span>$\chi$</span>.</p><p>Due to the abstract generality of the product algebra code generation, it is possible to extend the <code>Grassmann</code> library to include additional high performance products with few extra definitions. Operations on ultra-sparse representations for very high dimensional algebras will be gaining further performance enhancements in future updates, along with hybrid optimizations for low-dimensional algebra code generation. Thanks to the design of the product algebra code generation, any additional optimizations to the type stability will automatically enhance all the different products simultaneously. Likewise, any new product formulas will be able to quickly gain from the setup of all of the existing optimizations.</p><p>The <em>Grassmann.jl</em> package and its accompanying support packages provide an extensible platform for high performance computing with geometric algebra at high dimensions. This enables the usage of many different types of <code>TensorAlgebra</code> along with various <code>VectorBundle</code> parameters and interoperability for a wide range of scientific and research applications.</p><h2 id="Direct-sum-yields-VectorBundle-parametric-type-polymorphism-1"><a class="docs-heading-anchor" href="#Direct-sum-yields-VectorBundle-parametric-type-polymorphism-1">Direct-sum yields <code>VectorBundle</code> parametric type polymorphism ⨁</a><a class="docs-heading-anchor-permalink" href="#Direct-sum-yields-VectorBundle-parametric-type-polymorphism-1" title="Permalink"></a></h2><p>The <em>DirectSum.jl</em> package is a work in progress providing the necessary tools to work with an arbitrary <code>Manifold</code> specified by an encoding. Due to the parametric type system for the generating <code>VectorBundle</code>, the Julia compiler can fully preallocate and often cache values efficiently ahead of run-time. Although intended for use with the <em>Grassmann.jl</em> package, <code>DirectSum</code> can be used independently.</p><p>Let <code>N</code> be the rank of a <code>Manifold{N}</code>. The type <code>VectorBundle{N,P,g,ν,μ}</code> uses <em>byte-encoded</em> data available at pre-compilation, where <code>P</code> specifies the basis for up and down projection, <code>g</code> is a bilinear form that specifies the metric of the space, and <code>μ</code> is an integer specifying the order of the tangent bundle (i.e. multiplicity limit of Leibniz-Taylor monomials). Lastly, <code>ν</code> is the number of tangent variables.</p><p>The metric signature of the <code>Basis{V,1}</code> elements of a vector space <code>V</code> can be specified with the <code>V&quot;...&quot;</code> constructor by using <code>+</code> and <code>-</code> to specify whether the <code>Basis{V,1}</code> element of the corresponding index squares to <code>+1</code> or <code>-1</code>. For example, <code>S&quot;+++&quot;</code> constructs a positive definite 3-dimensional <code>VectorBundle</code>.</p><pre><code class="language-julia-repl">julia&gt; ℝ^3 == V&quot;+++&quot; == vectorspace(3)
true</code></pre><p>It is also possible to specify an arbitrary <code>DiagonalForm</code> having numerical values for the basis with degeneracy <code>D&quot;1,1,1,0&quot;</code>, although the <code>Signature</code> format has a more compact representation. Further development will result in more metric types.</p><p>Declaring an additional plane at infinity is done by specifying it in the string constructor with <code>∞</code> at the first index (i.e. Riemann sphere <code>S&quot;∞+++&quot;</code>). The hyperbolic geometry can be declared by <code>∅</code> subsequently (i.e. Minkowski spacetime <code>S&quot;∅+++&quot;</code>). Additionally, the <em>null-basis</em> based on the projective split for confromal geometric algebra would be specified with <code>∞∅</code> initially (i.e. 5D CGA <code>S&quot;∞∅+++&quot;</code>). These two declared basis elements are interpreted in the type system.</p><p>The <code>tangent</code> map takes <code>V</code> to its tangent space and can be applied repeatedly for higher orders, such that <code>tangent(V,μ,ν)</code> can be used to specify <code>μ</code> and <code>ν</code>.</p><pre><code class="language-julia-repl">julia&gt; V = tangent(ℝ^3)
⟨+++₁⟩

julia&gt; V&#39;
⟨---¹⟩&#39;

julia&gt; V+V&#39;
⟨+++---₁¹⟩*</code></pre><p>The direct sum operator <code>⊕</code> can be used to join spaces (alternatively <code>+</code>), and the dual space functor <code>&#39;</code> is an involution which toggles a dual vector space with inverted signature.</p><pre><code class="language-julia-repl">julia&gt; V = ℝ&#39;⊕ℝ^3
⟨-+++⟩

julia&gt; V&#39;
⟨+---⟩&#39;

julia&gt; W = V⊕V&#39;
⟨-++++---⟩*</code></pre><p>The direct sum of a <code>VectorBundle</code> and its dual <code>V⊕V&#39;</code> represents the full mother space <code>V*</code>.</p><pre><code class="language-julia-repl">julia&gt; collect(V) # all vector basis elements
Grassmann.Algebra{⟨-+++⟩,16}(v, v₁, v₂, v₃, v₄, v₁₂, v₁₃, v₁₄, v₂₃, v₂₄, v₃₄, v₁₂₃, v₁₂₄, v₁₃₄, v₂₃₄, v₁₂₃₄)

julia&gt; collect(V&#39;) # all covector basis elements
Grassmann.Algebra{⟨+---⟩&#39;,16}(w, w¹, w², w³, w⁴, w¹², w¹³, w¹⁴, w²³, w²⁴, w³⁴, w¹²³, w¹²⁴, w¹³⁴, w²³⁴, w¹²³⁴)

julia&gt; collect(W) # all mixed basis elements
Grassmann.Algebra{⟨-++++---⟩*,256}(v, v₁, v₂, v₃, v₄, w¹, w², w³, w⁴, v₁₂, v₁₃, v₁₄, v₁w¹, v₁w², v₁w³, v₁w⁴, v₂₃, v₂₄, v₂w¹, v₂w², v₂w³, v₂w⁴, v₃₄, v₃w¹, v₃w², v₃w³, v₃w⁴, v₄w¹, v₄w², v₄w³, v₄w⁴, w¹², w¹³, w¹⁴, w²³, w²⁴, w³⁴, v₁₂₃, v₁₂₄, v₁₂w¹, v₁₂w², v₁₂w³, v₁₂w⁴, v₁₃₄, v₁₃w¹, v₁₃w², v₁₃w³, v₁₃w⁴, v₁₄w¹, v₁₄w², v₁₄w³, v₁₄w⁴, v₁w¹², v₁w¹³, v₁w¹⁴, v₁w²³, v₁w²⁴, v₁w³⁴, v₂₃₄, v₂₃w¹, v₂₃w², v₂₃w³, v₂₃w⁴, v₂₄w¹, v₂₄w², v₂₄w³, v₂₄w⁴, v₂w¹², v₂w¹³, v₂w¹⁴, v₂w²³, v₂w²⁴, v₂w³⁴, v₃₄w¹, v₃₄w², v₃₄w³, v₃₄w⁴, v₃w¹², v₃w¹³, v₃w¹⁴, v₃w²³, v₃w²⁴, v₃w³⁴, v₄w¹², v₄w¹³, v₄w¹⁴, v₄w²³, v₄w²⁴, v₄w³⁴, w¹²³, w¹²⁴, w¹³⁴, w²³⁴, v₁₂₃₄, v₁₂₃w¹, v₁₂₃w², v₁₂₃w³, v₁₂₃w⁴, v₁₂₄w¹, v₁₂₄w², v₁₂₄w³, v₁₂₄w⁴, v₁₂w¹², v₁₂w¹³, v₁₂w¹⁴, v₁₂w²³, v₁₂w²⁴, v₁₂w³⁴, v₁₃₄w¹, v₁₃₄w², v₁₃₄w³, v₁₃₄w⁴, v₁₃w¹², v₁₃w¹³, v₁₃w¹⁴, v₁₃w²³, v₁₃w²⁴, v₁₃w³⁴, v₁₄w¹², v₁₄w¹³, v₁₄w¹⁴, v₁₄w²³, v₁₄w²⁴, v₁₄w³⁴, v₁w¹²³, v₁w¹²⁴, v₁w¹³⁴, v₁w²³⁴, v₂₃₄w¹, v₂₃₄w², v₂₃₄w³, v₂₃₄w⁴, v₂₃w¹², v₂₃w¹³, v₂₃w¹⁴, v₂₃w²³, v₂₃w²⁴, v₂₃w³⁴, v₂₄w¹², v₂₄w¹³, v₂₄w¹⁴, v₂₄w²³, v₂₄w²⁴, v₂₄w³⁴, v₂w¹²³, v₂w¹²⁴, v₂w¹³⁴, v₂w²³⁴, v₃₄w¹², v₃₄w¹³, v₃₄w¹⁴, v₃₄w²³, v₃₄w²⁴, v₃₄w³⁴, v₃w¹²³, v₃w¹²⁴, v₃w¹³⁴, v₃w²³⁴, v₄w¹²³, v₄w¹²⁴, v₄w¹³⁴, v₄w²³⁴, w¹²³⁴, v₁₂₃₄w¹, v₁₂₃₄w², v₁₂₃₄w³, v₁₂₃₄w⁴, v₁₂₃w¹², v₁₂₃w¹³, v₁₂₃w¹⁴, v₁₂₃w²³, v₁₂₃w²⁴, v₁₂₃w³⁴, v₁₂₄w¹², v₁₂₄w¹³, v₁₂₄w¹⁴, v₁₂₄w²³, v₁₂₄w²⁴, v₁₂₄w³⁴, v₁₂w¹²³, v₁₂w¹²⁴, v₁₂w¹³⁴, v₁₂w²³⁴, v₁₃₄w¹², v₁₃₄w¹³, v₁₃₄w¹⁴, v₁₃₄w²³, v₁₃₄w²⁴, v₁₃₄w³⁴, v₁₃w¹²³, v₁₃w¹²⁴, v₁₃w¹³⁴, v₁₃w²³⁴, v₁₄w¹²³, v₁₄w¹²⁴, v₁₄w¹³⁴, v₁₄w²³⁴, v₁w¹²³⁴, v₂₃₄w¹², v₂₃₄w¹³, v₂₃₄w¹⁴, v₂₃₄w²³, v₂₃₄w²⁴, v₂₃₄w³⁴, v₂₃w¹²³, v₂₃w¹²⁴, v₂₃w¹³⁴, v₂₃w²³⁴, v₂₄w¹²³, v₂₄w¹²⁴, v₂₄w¹³⁴, v₂₄w²³⁴, v₂w¹²³⁴, v₃₄w¹²³, v₃₄w¹²⁴, v₃₄w¹³⁴, v₃₄w²³⁴, v₃w¹²³⁴, v₄w¹²³⁴, v₁₂₃₄w¹², v₁₂₃₄w¹³, v₁₂₃₄w¹⁴, v₁₂₃₄w²³, v₁₂₃₄w²⁴, v₁₂₃₄w³⁴, v₁₂₃w¹²³, v₁₂₃w¹²⁴, v₁₂₃w¹³⁴, v₁₂₃w²³⁴, v₁₂₄w¹²³, v₁₂₄w¹²⁴, v₁₂₄w¹³⁴, v₁₂₄w²³⁴, v₁₂w¹²³⁴, v₁₃₄w¹²³, v₁₃₄w¹²⁴, v₁₃₄w¹³⁴, v₁₃₄w²³⁴, v₁₃w¹²³⁴, v₁₄w¹²³⁴, v₂₃₄w¹²³, v₂₃₄w¹²⁴, v₂₃₄w¹³⁴, v₂₃₄w²³⁴, v₂₃w¹²³⁴, v₂₄w¹²³⁴, v₃₄w¹²³⁴, v₁₂₃₄w¹²³, v₁₂₃₄w¹²⁴, v₁₂₃₄w¹³⁴, v₁₂₃₄w²³⁴, v₁₂₃w¹²³⁴, v₁₂₄w¹²³⁴, v₁₃₄w¹²³⁴, v₂₃₄w¹²³⁴, v₁₂₃₄w¹²³⁴)</code></pre><p>In addition to the direct-sum operation, several other operations are supported, such as <code>∪,∩,⊆,⊇</code> for set operations. Due to the design of the <code>VectorBundle</code> dispatch, these operations enable code optimizations at compile-time provided by the bit parameters.</p><pre><code class="language-julia-repl">julia&gt; ℝ+ℝ&#39; ⊇ vectorspace(1)
true

julia&gt; ℝ ∩ ℝ&#39; == vectorspace(0)
true

julia&gt; ℝ ∪ ℝ&#39; == ℝ+ℝ&#39;
true</code></pre><p><strong>Remark</strong>. Although some of the operations like <code>∪</code> and <code>⊕</code> are similar and sometimes result in the same values, the <code>union</code> and <code>sum</code> are entirely different operations in general.</p><p>Calling manifolds with sets of indices constructs the subspace representations. Given <code>M(s::Int...)</code> one can encode <code>SubManifold{length(s),M,s}</code> with induced orthogonal space, such that computing unions of submanifolds is done by inspecting the parameter <code>s</code>. Operations on <code>Manifold</code> types is automatically handled at compile time.</p><p>More information about <code>DirectSum</code> is available  at https://github.com/chakravala/DirectSum.jl</p><h2 id="Interoperability-for-TensorAlgebra{V}-1"><a class="docs-heading-anchor" href="#Interoperability-for-TensorAlgebra{V}-1">Interoperability for <code>TensorAlgebra{V}</code></a><a class="docs-heading-anchor-permalink" href="#Interoperability-for-TensorAlgebra{V}-1" title="Permalink"></a></h2><p>The <code>AbstractTensors</code> package is intended for universal interoperability of the abstract <code>TensorAlgebra</code> type system. All <code>TensorAlgebra{V}</code> subtypes have type parameter <code>V</code>, used to store a <code>VectorBundle</code> value obtained from <em>DirectSum.jl</em>. By itself, this package does not impose any specifications or structure on the <code>TensorAlgebra{V}</code> subtypes and elements, aside from requiring <code>V</code> to be a <code>VectorBundle</code>. This means that different packages can create tensor types having a common underlying <code>VectorBundle</code> structure.</p><p>The key to making the whole interoperability work is that each <code>TensorAlgebra</code> subtype shares a <code>VectorBundle</code> parameter (with all <code>isbitstype</code> parameters), which contains all the info needed at compile time to make decisions about conversions. So other packages need only use the vector space information to decide on how to convert based on the implementation of a type. If external methods are needed, they can be loaded by <code>Requires</code> when making a separate package with <code>TensorAlgebra</code> interoperability.</p><p>Since <code>VectorBundle</code> choices are fundamental to <code>TensorAlgebra</code> operations, the universal interoperability between <code>TensorAlgebra{V}</code> elements with different associated <code>VectorBundle</code> choices is naturally realized by applying the <code>union</code> morphism to operations. Some of the method names like <code>+,-,\otimes,\times,\cdot,*</code> for <code>TensorAlgebra</code> elements are shared across different packages, with interoperability.</p><p>Additionally, a universal unit volume element can be specified in terms of <code>LinearAlgebra.UniformScaling</code>, which is independent of <code>V</code> and has its interpretation only instantiated by the context of the <code>TensorAlgebra{V}</code> element being operated on. The universal interoperability of <code>LinearAlgebra.UniformScaling</code> as a pseudoscalar element which takes on the <code>VectorBundle</code> form of any other <code>TensorAlgebra</code> element is handled globally. This enables the usage of <code>I</code> from <code>LinearAlgebra</code> as a universal pseudoscalar element.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../algebra/">Algebra »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 15 December 2019 22:27">Sunday 15 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
