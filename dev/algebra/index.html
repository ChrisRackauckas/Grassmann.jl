<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algebra · Grassmann.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Grassmann.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Algebra</a><ul class="internal"><li><a class="tocitem" href="#Null-basis-of-the-projective-split-1"><span>Null-basis of the projective split</span></a></li><li><a class="tocitem" href="#Differential-forms-and-tangent-algebra-1"><span>Differential forms and tangent algebra</span></a></li><li><a class="tocitem" href="#Symbolic-coefficients-by-declaring-algebra-1"><span>Symbolic coefficients by declaring algebra</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../agpl/">AGPL-3.0</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/quick-start/">Quick start (G2)</a></li><li><a class="tocitem" href="../tutorials/algebra-of-space/">The Algebra of Space (G3)</a></li><li><a class="tocitem" href="../tutorials/dyadic-tensors/">Dyadic tensor product ⊗</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Grassmann.jl/blob/master/docs/src/algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Grassmann-elements-and-geometric-algebra-Λ(V)-1"><a class="docs-heading-anchor" href="#Grassmann-elements-and-geometric-algebra-Λ(V)-1">Grassmann elements and geometric algebra Λ(V)</a><a class="docs-heading-anchor-permalink" href="#Grassmann-elements-and-geometric-algebra-Λ(V)-1" title="Permalink"></a></h1><p>The Grassmann <code>SubManifold</code> elements <span>$v_k\in\Lambda^1V$</span> and <span>$w^k\in\Lambda^1V&#39;$</span> are linearly independent vector and covector elements of <span>$V$</span>, while the Leibniz <code>Operator</code> elements <span>$\partial_k\in L^1V$</span> are partial tangent derivations and <span>$\epsilon_k\in L^1V&#39;$</span> are dependent functions of the <code>tangent</code> manifold. Let <span>$V\in\text{Vect}_{\mathbb k}$</span> be a <code>TensorBundle</code> with dual space <span>$V&#39;$</span> and the basis elements <span>$w_k:V\rightarrow\mathbb K$</span>, then for all <span>$x\in V,c\in\mathbb K$</span> it holds: <span>$(w^i+w^j)(x) = w^i(x)+w^j(x)$</span> and <span>$(cw^k)(x) = cw^k(x)$</span> hold. An element of a mixed-symmetry <code>TensorAlgebra{V}</code> is a multilinear mapping that is formally constructed by taking the tensor products of linear and multilinear maps, <span>$(\bigotimes_k \omega_k)(v_1,\dots,v_{\sum_k p_k}) = \prod_k \omega_k(v_1,\dots,v_{p_k})$</span>. Higher <code>grade</code> elements correspond to <code>SubManifold</code> subspaces, while higher <code>order</code> function elements become homogenous polynomials and Taylor series.</p><pre><code class="language-julia-repl">julia&gt; Λ(ℝ^3)
DirectSum.Basis{⟨+++⟩,8}(v, v₁, v₂, v₃, v₁₂, v₁₃, v₂₃, v₁₂₃)

julia&gt; Λ(tangent(ℝ^2))
DirectSum.Basis{T¹⟨++₁⟩,8}(v, v₁, v₂, ∂₁, v₁₂, ∂₁v₁, ∂₁v₂, ∂₁v₁₂)

julia&gt; Λ(tangent((ℝ^0)&#39;,3,3))
DirectSum.Basis{T³⟨¹²³⟩&#39;,8}(w, ϵ₁, ϵ₂, ϵ₃, ϵ₁₂, ϵ₁₃, ϵ₂₃, ϵ₁₂₃)</code></pre><p>Combining the linear basis generating elements with each other using the multilinear tensor product yields a graded (decomposable) tensor <code>SubManifold</code> <span>$\langle v_{i_1}\otimes\cdots\otimes v_{i_k}\rangle_k : V&#39;^k\rightarrow\mathbb K$</span>, where <code>rank</code> is determined by the sum of basis index multiplicities in the tensor product decomposition. The Grassmann anti-symmetric exterior basis is denoted by <span>$v_{i_1\dots i_g}\in\Lambda^gV$</span> having the dual elements <span>$w^{i_1\cdots i_g}\in\Lambda^gV&#39;$</span>, while the Leibniz symmetric basis will be denoted by <span>$\partial_{i_1}^{\mu_1}\dots\partial_{i_g}^{\mu_g}\in L^gV$</span> with corresponding <span>$\epsilon_{i_1}^{\mu_1}\dots\epsilon_{i_g}^{\mu_g}\in L^gV&#39;$</span> adjoint elements. Combined, this space produces the full Leibniz tangent algebra <span>$T^\mu V=V\oplus (\bigoplus_{g=1}^\mu L^g V)$</span> and the Grassmann exterior algebra <span>$\Lambda V = \bigoplus_{g=1}^n\Lambda^g V$</span> with <span>$2^n$</span> elements. The mixed index algebra <span>$\Lambda(T^\mu V) = (\bigoplus_{g=1}^n\Lambda^g V)\oplus(\bigoplus_{g=1}^\mu L^g V)$</span> is partitioned into both symmetric and anti-symmetric tensor equivalence classes. Any mixed tensor <code>SubManifold</code> pair <span>$\omega,\eta$</span> satisfies either</p><div>\[\underbrace{\omega\otimes\eta = -\eta\otimes\omega}_{\text{anti-symmetric}} \qquad \text{or} \qquad  \underbrace{\omega\otimes\eta = \eta\otimes\omega}_{\text{symmetric}}.\]</div><p>For the oriented sets of the Grassmann exterior algebra, the parity of <span>$(-1)^\Pi$</span> is factored into transposition compositions when interchanging ordering of the tensor product argument permutations. The symmetrical algebra does not need to track this parity, but has higher multiplicities in its indices. Symmetric differential function algebra of Leibniz trivializes the orientation into a single class of index multi-sets, while Grassmann&#39;s exterior algebra is partitioned into two oriented equivalence classes by anti-symmetry. Full tensor algebra can be sub-partitioned into equivalence classes in multiple ways based on the element symmetry, grade, and metric signature composite properties. Both symmetry classes can be characterized by the same geometric product.</p><pre><code class="language-julia-repl">julia&gt; indices(Λ(3).v12)
2-element Array{Int64,1}:
 1
 2</code></pre><p>A higher-order composite tensor element is an oriented-multi-set <span>$X$</span> such that <span>$v_X = \bigotimes_k v_{i_k}^{\otimes\mu_k}$</span> with the indices <span>$X = \left((i_1,\mu_1),\dots,(i_g,\mu_g)\right)$</span> and <span>$|X|=\sum_k\mu_k$</span> is tensor <code>rank</code>. Anti-symmetric indices <span>$\Lambda X\subseteq\Lambda V$</span> have two orientations and higher multiplicities of them result in zero values, so the only interesting multiplicity is <span>$\mu_k\equiv1$</span>. The Leibniz-Taylor algebra is a quotient polynomial ring <span>$LV\cong R[x_1,\dots,x_n]/\{\prod_{k=1}^{\mu+1} x_{p_k}\}$</span> so that <span>$\partial_k^{\mu+1}$</span> is zero. Typically the <span>$k$</span> in a product <span>$\left(\partial_{p_1}\otimes\cdots\otimes\partial_{p_k}\right)^{(k)}$</span> is referred to as the <code>order</code> of the element if it is fully symmetric, which is overall tracked separately from the <code>grade</code> such that <span>$\partial_k\langle v_j\rangle_r = \langle\partial_kv_j\rangle_r$</span> and <span>$(\partial_k)^{(r)}\omega_j = (\partial_kv_j)^{(r)}$</span>. There is a partitioning into <code>even</code> grade components <span>$\omega_+$</span> and <code>odd</code> grade components <span>$\omega_-$</span> such that <span>$\omega_++\omega_-=\omega$</span>.</p><p>Grassmann&#39;s exterior algebra doesn&#39;t invoke the properties of multi-sets, as it is related to the algebra of oriented sets; while the Leibniz symmetric algebra is that of unoriented multi-sets. Combined, the mixed-symmetry algebra yield a multi-linear propositional lattice. The formal sum of equal <code>grade</code> elements is an oriented <code>Chain</code> and with mixed <code>grade</code> it is a <code>MultiVector</code> simplicial complex. Thus, various standard operations on the oriented multi-sets are possible including <span>$\cup,\cap,\oplus$</span> and the index operation <span>$\ominus$</span>, which is symmetric difference operation.</p><p>By virtue of Julia&#39;s multiple dispatch on the field type <span>$\mathbb K$</span>, methods can specialize on the dimension <span>$n$</span> and grade <span>$G$</span> with a <code>TensorBundle{n}</code> via the <code>TensorAlgebra{V}</code> subtypes, such as <code>SubManifold{V,G}</code>, <code>Simplex{V,G,B,𝕂}</code>, <code>Chain{V,G,𝕂}</code>, <code>SparseChain{V,G,𝕂}</code>, <code>MultiVector{V,𝕂}</code>, and <code>MultiGrade{V,G}</code> types.</p><p>The elements of the <code>Basis</code> can be generated in many ways using the <code>SubManifold</code> elements created by the <code>@basis</code> macro,</p><pre><code class="language-julia-repl">julia&gt; using Grassmann; @basis ℝ&#39;⊕ℝ^3 # equivalent to basis&quot;-+++&quot;
(⟨-+++⟩, v, v₁, v₂, v₃, v₄, v₁₂, v₁₃, v₁₄, v₂₃, v₂₄, v₃₄, v₁₂₃, v₁₂₄, v₁₃₄, v₂₃₄, v₁₂₃₄)</code></pre><p>As a result of this macro, all of the <code>SubManifold{V,G}</code> elements generated by that <code>TensorBundle</code> become available in the local workspace with the specified naming. The first argument provides signature specifications, the second argument is the variable name for the <code>TensorBundle</code>, and the third and fourth argument are prefixes of the <code>SubManifold</code> vector names (and covector basis names). By default, <span>$V$</span> is assigned the <code>TensorBundle</code> and <span>$v$</span> is the prefix for the <code>SubManifold</code> elements.</p><pre><code class="language-julia-repl">julia&gt; V # Minkowski spacetime
⟨-+++⟩

julia&gt; typeof(V) # dispatch by vector space
SubManifold{⟨-+++⟩,4,0x000000000000000f}

julia&gt; typeof(v13) # extensive type info
SubManifold{⟨-+++⟩,2,0x0000000000000005}

julia&gt; 2v1 + v3 # vector Chain{V,1} element
2v₁ + 0v₂ + 1v₃ + 0v₄

julia&gt; 5 + v2 + v234 # MultiVector{V} element
5 + 1v₂ + 1v₂₃₄</code></pre><p>It is entirely possible to assign multiple different bases with different signatures without any problems. In the following command, the <code>@basis</code> macro arguments are used to assign the vector space name to <span>$S$</span> instead of <span>$V$</span> and basis elements to <span>$b$</span> instead of <span>$v$</span>, so that their local names do not interfere:</p><pre><code class="language-julia-repl">julia&gt; @basis &quot;++++&quot; S b;

julia&gt; let k = (b1 + b2) - b3
          for j ∈ 1:9
       	   k = k * (b234 + b134)
       	   println(k)
       end end
0 + 1v₁₄ + 1v₂₄ + 2v₃₄
0 - 2v₁ - 2v₂ + 2v₃
0 - 2v₁₄ - 2v₂₄ - 4v₃₄
0 + 4v₁ + 4v₂ - 4v₃
0 + 4v₁₄ + 4v₂₄ + 8v₃₄
0 - 8v₁ - 8v₂ + 8v₃
0 - 8v₁₄ - 8v₂₄ - 16v₃₄
0 + 16v₁ + 16v₂ - 16v₃
0 + 16v₁₄ + 16v₂₄ + 32v₃₄</code></pre><p>Alternatively, if you do not wish to assign these variables to your local workspace, the versatile constructors of <code>DirectSum.Basis{V}</code> can be used to contain them, which is exported to the user as the method <code>Λ(V)</code>,</p><pre><code class="language-julia-repl">julia&gt; G3 = Λ(3) # equivalent to Λ(V&quot;+++&quot;), Λ(ℝ^3), Λ.V3
DirectSum.Basis{⟨+++⟩,8}(v, v₁, v₂, v₃, v₁₂, v₁₃, v₂₃, v₁₂₃)

julia&gt; G3.v13 ⊖ G3.v12
1v₂₃</code></pre><p>The multiplication product used: <span>$*$</span> or <span>$\ominus$</span> is the geometric algebraic product.</p><p><strong>Definition</strong>. The <em>geometric algebraic product</em> is the oriented symmetric difference operator <span>$\ominus$</span> (weighted by the bilinear form <span>$g$</span>) and multi-set sum <span>$\oplus$</span> applied to multilinear tensor products <span>$\otimes$</span> in a single operation.</p><div>\[\omega_X\ominus \eta_Y = \underbrace{\overbrace{(-1)^{\Pi(X,Y)}}^{\text{orient parity}}\overbrace{\det\left[g_{\Lambda(X\cap Y)}\right]}^{\text{intersect metric}} (\overbrace{\bigotimes_{k\in \Lambda(X\ominus Y)} v^{i_k}}^{(X\cup Y)\backslash(X\cap Y)}}_{\Lambda^1-anti-symmetric,\, \Lambda^g-mixed-symmetry})\otimes (\underbrace{\overbrace{\bigotimes_{k\in L(X\oplus Y)} \partial_{i_k}^{\otimes\mu_k}}^{\text{multi-set sum}}}_{L^g-symmetric})\]</div><p><strong>Remark</strong>: The product symbol <span>$\ominus$</span> will be used to denote explicitly usage of the geometric algebraic product, although the standard number product <span>$*$</span> notation could also be used. The <span>$\ominus$</span> choice helps emphasize that the geometric algebraic product is characterized by symmetric differencing of anti-symmetric indices.</p><pre><code class="language-julia-repl">julia&gt; (1 + 2v34) ⊖ (3 + 4v34), (1 + 2v34) * (3 + 4v34), (1 + 2im) * (3 + 4im)
(-5 + 10v₃₄, -5 + 10v₃₄, -5 + 10im)</code></pre><p>Symmetry properties of the tensor algebra can be characterized in terms of the geometric product by two averaging operations, which are the symmetrization <span>$\odot$</span> and anti-symmetrization <span>$\boxtimes$</span> operators. These products satisfy various <code>MultiVector</code> properties, including the associative and distributive laws.</p><p><strong>Definition</strong> (Exterior product): Let <span>$w_k\in\Lambda^{p_k}V$</span>, then for all <span>$\sigma\in S_{\sum p_k}$</span> define an equivalence relation <span>$\sim$</span> such that</p><div>\[\bigwedge_k \omega_k(v_{1},\dots,v_{p_k}) \sim (-1)^{\Pi(\sigma)}(\bigotimes_k \omega_k)(v_{\sigma(1)},\dots,v_{\sigma(\sum p_k)})\]</div><p>if and only if <span>$\ominus_k\omega_k = \boxtimes_k\omega_k$</span> holds. It has become typical to use the <span>$\wedge$</span> product symbol to denote products of such elements as <span>$\bigwedge\Lambda V \equiv \bigotimes\Lambda V/\sim$</span> modulo anti-symmetrization.</p><pre><code class="language-julia-repl">julia&gt; v3 ∧ v4, v4 ∧ v3, v3 ∧ v3
(v₃₄, -1v₃₄, 0v)</code></pre><p><strong>Remark</strong>. Observe that the anti-symmetric property implies that <span>$\omega\otimes\omega=0$</span>, while the symmetric property neither implies nor denies such a property. Grassmann remarked in 1862 that the symmetric algebra of functions is by far more complicated than his anti-symmetric exterior algebra. The first part of the book focused on anti-symmetric exterior algebra, while the more complex symmetric function algebra of Leibniz was subject of the second multivariable part of the book. Elements <span>$\omega_k$</span> in the space <span>$\Lambda V$</span> of anti-symmetric algebra are often studied as unit quantum state vectors in a unitary probability space, where <span>$\sum_k\omega_k\neq\bigotimes_k\omega_k$</span> is entanglement.</p><p><strong>Definition</strong> (Reverse, involute, conjugate). The <code>reverse</code> of <span>$\langle\omega\rangle_r$</span> is defined as <span>$\langle\tilde\omega\rangle_r = (-1)^{(r-1)r/2}\langle\omega\rangle_r$</span>, while the <code>involute</code> is <span>$\langle\omega\rangle_r^\times=(-1)^r\langle\omega\rangle_r$</span> and <code>clifford</code>  <span>$\langle\omega\rangle_r^\ddagger$</span> is the composition of <code>involute</code> and <code>reverse</code>.</p><pre><code class="language-julia-repl">julia&gt; clifford(v234) == involute(~v234)
true</code></pre><p><strong>Definition</strong> (Reversed product). Define the index reversed product <span>$\ast$</span> which yields a Hilbert space structure:</p><div>\[\omega\ast\eta = \tilde\omega\ominus\eta, \quad \omega\ast&#39;\eta = \omega\ominus\tilde\eta, \qquad |\omega|^2 = \omega\ast\omega, \quad |\omega| = \sqrt{\omega\ast\omega}, \quad ||\omega|| = \text{Euclidean }|\omega|.\]</div><p><strong>Remark</strong>. Observe that <span>$\ast$</span> and <span>$\ast&#39;$</span> could both be exchanged in <code>abs</code>, <code>abs2</code>, and <code>norm</code>; however, these are different products. The <em>scalar product</em> <span>$\circledast$</span> is the <code>scalar</code> part, so <span>$\eta\circledast\omega = \langle\eta\ast\omega\rangle$</span>.</p><pre><code class="language-julia-repl">julia&gt; 2v34 ⊖ 2v34, 2v34 * 2v34, 2v34 ∗ 2v34, 2v34 ⊛ 2v34 # (gp, gp, rp, sp)
(-4v, -4v, 4v, 4v)

julia&gt; abs2(2v34), abs(2v34), norm(2v34) # application of reverse product
(4v, 2.0v, 2.0)</code></pre><p><strong>Definition</strong> (Inverse). <span>$\omega^{-1} = \omega\ast(\omega\ast\omega)^{-1} = \tilde\omega/|\omega|^2$</span>, with <span>$\eta/\omega = \eta\ominus\omega^{-1}$</span> and <span>$\eta\backslash\omega = \eta^{-1}\ominus\omega$</span>.</p><pre><code class="language-julia-repl">julia&gt; 1/v34, inv(v34) == ~v34/abs2(v34)
(-1.0v₃₄, true)</code></pre><p><strong>Definition</strong> (Sandwich product). This product can be defined as <span>$\eta\oslash\omega = \omega\backslash\eta\ominus\omega^\times$</span>. Alternatively, the reversed definition is <span>$\eta^\times\ominus\omega/\eta$</span> or in Julia <code>η&gt;&gt;&gt;ω</code>, which is often found in literature.</p><pre><code class="language-julia-repl">julia&gt; (2v3+5v4) ⊘ v3 == inv(v3)*(2v3+5v4)*involute(v3)
true</code></pre><p><strong>Remark</strong>. Observe that it is overall more simple and consistent to use <span>$\{\ast,\oslash\}$</span> operations instead of the reversed.</p><p>The <code>real</code> part <span>$\Re\omega = (\omega+\tilde\omega)/2$</span> is defined by <span>$|\Re\omega|^2 = (\Re\omega)^{\ominus2}$</span> and the <code>imag</code> part <span>$\Im\omega = (\omega-\tilde\omega)/2$</span> by <span>$|\Im\omega|^2 = -(\Im\omega)^{\ominus2}$</span>, such that <span>$\omega = \Re\omega+\Im\omega$</span> has real and imaginary partitioned by</p><div>\[\langle\tilde\omega\rangle_r/\left|\langle\omega\rangle_r\right| = \sqrt{\langle\tilde\omega\rangle_r^2/\big|\langle\omega\rangle_r\big|^2} = \sqrt{\langle\omega\rangle_r\ast\langle\omega\rangle_r^{-1}} = \sqrt{\langle\tilde\omega\rangle_r/\langle\omega\rangle_r}=\sqrt{(-1)^{(r-1)r/2}} \in\{1,\sqrt{-1}\},\]</div><p>which is a unique partitioning completely independent of the metric space and manifold of the algebra.</p><div>\[\omega\ast\omega = |\omega|^2 = |\Re\omega+\Im\omega|^2 = |\Re\omega|^2+|\Im\omega|^2 + 2\Re(\Re\omega\ast\Im\omega)\]</div><p>The <code>radial</code> and <code>angular</code> components in a multivector exponential are partitioned by the parity of their metric.</p><p>It is possible to assign the <strong>quaternion</strong> generators <span>$i,j,k$</span> with</p><pre><code class="language-julia-repl">julia&gt; i,j,k = hyperplanes(ℝ^3)
3-element Array{Simplex{⟨+++⟩,2,B,Int64} where B,1}:
 -1v₂₃
  1v₁₃
 -1v₁₂

julia&gt; i^2, j^2, k^2, i*j*k
(-1v, -1v, -1v, -1v)

julia&gt; -(j+k) * (j+k)
2v⃖

julia&gt; -(j+k) * i
0 - 1v₁₂ - 1v₁₃</code></pre><p>Alternatively, another representation of the quaternions is</p><pre><code class="language-julia-repl">julia&gt; basis&quot;--&quot;
(⟨--⟩, v, v₁, v₂, v₁₂)

julia&gt; v1^2, v2^2, v12^2, v1*v2*v12
(-1v, -1v, -1v, -1v)</code></pre><p>The parametric type formalism in <code>Grassmann</code> is highly expressive to enable the pre-allocation of geometric algebra computations for specific sparse-subalgebras, including the representation of rotational groups, Lie bivector algebras, and affine projective geometry. All of this is enabled by the psuedoscalar complement duality.</p><p><strong>Definition</strong> (Poincare-Hodge dual complement): Let <span>$\star\langle\omega\rangle_p = \langle\omega\rangle_p\ast I = \langle\tilde\omega\rangle_p\ominus I$</span>, then <span>$\star : \Lambda^pV\rightarrow\Lambda^{n-p}V$</span>.</p><p><strong>Remark</strong>. While <span>$\star\omega$</span> is <code>complementrighthodge</code> of <span>$\omega$</span>, the <code>complementlefthodge</code> would be <span>$I\ast&#39;\omega$</span>. The <span>$\star$</span> symbol was added to the Julia language as unary operator for ease of use with <code>Grassmann</code> on Julia&#39;s v1.2 release.</p><p>With <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>, <a href="https://github.com/JuliaGraphs/GraphPlot.jl">GraphPlot.jl</a>, <a href="https://github.com/JuliaGraphics/Cairo.jl">Cairo.jl</a>, <a href="https://github.com/GiovineItalia/Compose.jl">Compose.jl</a> it is possible to convert <code>Grassmann</code> numbers into graphs.</p><pre><code class="language-julia">using Grassmann, Compose # environment: LightGraphs, GraphPlot
x = Λ(ℝ^7).v123
Grassmann.graph(x+!x)
draw(PDF(&quot;simplex.pdf&quot;,16cm,16cm),x+!x)</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/triangle-tetrahedron.png" alt="paper/img/triangle-tetrahedron.png"/></p><p><em>Figure</em>. Triangle with its tetrahedron complement <span>$v_{123} + \star v_{123}$</span> in <span>$\mathbb R^7$</span>.</p><p>John Browne has discussed Grassmann duality principle in <a href="https://grassmannalgebra.com">book</a>, stating that every theorem (involving either of the exterior and regressive products) can be translated into its dual theorem by replacing the <span>$\wedge$</span> and <span>$\vee$</span> operations and applying <em>Poincare duality</em> (homology). Applying this Grassmann duality principle to the <span>$\wedge$</span> product, let <span>$P=\sum_kp_k$</span>, <span>$\{\omega_k\}_k\in\Lambda^{p_k}V$</span>, then it is possible to obtain the co-product <span>$\bigvee :\Lambda^{p_1}V_1\times\dots\times\Lambda^{p_g}V_g \rightarrow \Lambda^{P-(g-1)\#V}\bigcup_k V_k$</span>. Grassmann&#39;s original notation implicitly combined <span>$\wedge,\vee,\star$</span>. The join <span>$\wedge$</span> product is analogous to union <span>$\cup$</span>, the meet <span>$\vee$</span> product is analogous to intersection <span>$\cap$</span>, and the orthogonal complement <span>$\star\mapsto^\perp$</span> is negation. Together, <span>$(\wedge,\vee,\star)$</span> yield an orthocomplementary propositional lattice (quantum logic):</p><div>\[(\star\bigvee_k \omega_k)(v_1,\dots,v_P) = (\bigwedge_k\star\omega_k)(v_1,\dots,v_P) \quad DeMorgan&#39;s\,Law,\]</div><p>where DeMorgan&#39;s law is used to derive tensor contractions.</p><p><strong>Definition</strong>. Symmetrically define skew left <span>$\lrcorner$</span> and right <span>$\llcorner$</span> contractions <span>$\langle\omega\rangle_r\cdot\langle\eta\rangle_s = \begin{cases} \omega\llcorner\eta=\omega\vee\star\eta &amp; r\geq s \\ \omega\lrcorner\eta=\eta\vee\star\omega &amp; r\leq s \end{cases}$</span>. Note for <span>$\omega,\eta$</span> of equal grade, <span>$\omega\circledast\eta = \omega\odot\eta = \omega\cdot\eta = \omega\llcorner\eta = \omega\lrcorner\eta$</span> are all symmetric. In Julia, <span>$\lrcorner$</span> is <span>$&lt;$</span> and <span>$\llcorner$</span> is <span>$&gt;$</span>.</p><pre><code class="language-julia-repl">julia&gt; (G3.v1 + G3.v2) ⋅ (1.5G3.v2 + G3.v3)
1.5v</code></pre><p><strong>Definition</strong>. Let <span>$\nabla = \sum_k\partial_kv_k$</span> be a vector field and <span>$\epsilon = \sum_k\epsilon_k(x)w_k \in \Omega^1V$</span> be unit sums of the mixed-symmetry basis. Elements of <span>$\Omega^pV$</span> are known as <em>differential</em> <span>$p$</span>-<em>forms</em> and both <span>$\nabla$</span> and <span>$\epsilon$</span> are <em>tensor fields</em> dependent on <span>$x\in W$</span>. Another notation for a differential form is <span>$dx_k = \epsilon_k(x)w_k$</span>, such that <span>$\epsilon_k = dx_k/w_k$</span> and <span>$\partial_k\omega(x) = \omega&#39;(x)$</span>.</p><pre><code class="language-julia-repl">julia&gt; tangent(ℝ^3)(∇)
0v₁₂ + 0v₁₃ + 1∂₁v₁ + 0v₂₃ + 1∂₁v₂ + 1∂₁v₃

julia&gt; (ℝ^3)(∇)
1v₁ + 1v₂ + 1v₃</code></pre><p><strong>Remark</strong>. The space <span>$W$</span> does not have to equal <span>$V\in\text{Vect}_{\mathbb K}$</span> above, as <span>$\Omega^pV$</span> could have coefficients from <span>$\mathbb K = LW$</span>.</p><p><strong>Definition</strong>. Define differential <span>$d:\Omega^p V\rightarrow\Omega^{p+1}V$</span> and co-differential <span>$\delta:\Omega^pV\rightarrow\Omega^{p-1}V$</span> such that</p><div>\[\star d\omega = \star(\nabla\wedge\omega) = \nabla\times\omega, \qquad \omega\cdot\nabla = \omega\vee\star\nabla = \partial\omega =-\delta\omega.\]</div><p>Vorticity curl of vector-field: <span>$\star d(dx_1+dx_2+dx_3) = (∂_2 -∂_3)dx_1 + (∂_3 -∂_1)dx_2 + (∂_1 -∂_2)dx_3$</span>.</p><pre><code class="language-julia-repl">julia&gt; @basis tangent(ℝ^3,2,3); ⋆d(v1+v2+v3)
0 - 1∂₂v₁ + 1∂₃v₁ + 1∂₁v₂ - 1∂₃v₂ - 1∂₁v₃ + 1∂₂v₃</code></pre><p>Boundary of 3-simplex, faces of simplex (oriented): <span>$\partial(v_{1234}) = -\partial_4v_{123}+\partial_3v_{124}-\partial_2v_{134}+\partial_1v_{234}$</span>.</p><pre><code class="language-julia-repl">julia&gt; ∂(Λ(tangent(ℝ^4,2,4)).v1234)
0.0 - 1∂₄v₁₂₃ + 1∂₃v₁₂₄ - 1∂₂v₁₃₄ + 1∂₁v₂₃₄</code></pre><p>These two maps have the special properties <span>$d\circ d=0$</span> and <span>$\partial\circ\partial = 0$</span> for any form <span>$\omega$</span> and vector field <span>$\nabla$</span>. In topology there is <em>boundary</em> operator <span>$\partial$</span> defined by <span>$\partial\epsilon = \epsilon\cdot\nabla = \sum_k\partial_k\epsilon_k$</span> and is commonly discussed in terms the limit <span>$\epsilon(x)\cdot\nabla\omega(x) = \lim_{h\rightarrow0} \frac{\omega(x+h\epsilon)-\omega(x)}{h}$</span>, which is the directional derivative.</p><p><strong>Theorem</strong> (Integration by parts &amp; Stokes). Let <span>$\nabla \in\Omega_1 V$</span> be a Leibnizian vector field operator, then <span>$d,-\partial$</span> are Hilbert adjoint Hodge-DeRahm operators with</p><div>\[\int_M d\omega\wedge\star\eta +\int_M \omega\wedge\star\partial\eta = 0, \qquad \langle d\omega\ast\eta\rangle =\langle\omega\ast-\partial\eta\rangle.\]</div><p><em>Proof</em>. Recall, <span>$\partial\omega = \omega\cdot\nabla = \star^{-1}(\star\omega\wedge\star^2\nabla) = (-1)^n(-1)^{nk}\star d\star\omega$</span>. Then  substitute this into the integral <span>$\int_M \omega\wedge(-1)^{mk+m+1}\star\star d\star\eta = (-1)^{km+m+1}(-1)^{(m-k+1)(k-1)}\int_M\omega\wedge d\star\eta$</span>, and apply the identity <span>$(-1)^{km+m+1}(-1)^{(m-k+1)(k-1)}=(-1)^k$</span> and <span>$(-1)^k\int_M\omega\wedge d\star\eta = \int_M d(\omega\wedge\star\eta) - (-1)^{k-1}\omega\wedge d\star\eta = \int_M d\omega\wedge\star\eta$</span>. Stokes identity can be proved by relying on a variant of the <em>common factor theorem</em> by Browne.</p><p><strong>Theorem</strong> (Clifford-Dirac-Laplacian) Dirac operator is <span>$(\nabla^2)^\frac12\omega = \pm\nabla\ominus\omega = \pm\nabla\wedge\omega \pm \nabla\cdot\omega  = \pm d\omega\pm\partial\omega$</span>.</p><div>\[\nabla^2\omega = \nabla\wedge(\omega\cdot\nabla) + (\nabla\wedge\omega)\cdot\nabla) = \mp(\mp\omega\ominus\nabla)\ominus\nabla).\]</div><p>Elements <span>$\omega\in\mathcal H^p M = \{\nabla\omega = 0\mid\omega\in \Omega^pM\}$</span> are <em>harmonic</em> forms if <span>$\nabla\omega = 0$</span> and hence both <em>closed</em> <span>$d\omega=0$</span> and <em>coclosed</em> <span>$\delta\omega=0$</span>. Hodge decomposition: <span>$\Omega^pM=\mathcal H^pM\oplus\text{im}(d\Omega^{p-1}M)\oplus\text{im}(\partial\Omega^{p+1}M)$</span>.</p><pre><code class="language-julia-repl">julia&gt; ω = 4.5v12 + 7.4v13
4.5v₁₂ + 7.4v₁₃ + 0.0∂₁v₁ + 0.0∂₂v₁ + 0.0∂₃v₁ + 0.0v₂₃ + 0.0∂₁v₂ + 0.0∂₂v₂ + 0.0∂₃v₂ + 0.0∂₁v₃ + 0.0∂₂v₃ + 0.0∂₃v₃ + 0.0∂₁₂ + 0.0∂₁₃ + 0.0∂₂₃

julia&gt; V(∇^2)*ω == V(∇)*V(∇)*ω == d(∂(ω)) + ∂(d(ω))
true</code></pre><p>Let <span>$\nabla\in\Lambda^1V$</span>, then <span>$\omega = (\nabla\backslash\nabla)\ominus\omega = \nabla\backslash(d\omega + \partial\omega)$</span> where <span>$\nabla\parallel\partial\omega$</span> and <span>$\nabla\perp d\omega$</span>. Let&#39;s reflect across the hyperplane <span>$\star\nabla$</span>, then <span>$\nabla\backslash (d\omega-\partial\omega) = \nabla\backslash(d\omega-\partial\omega)\ominus(\nabla\backslash\nabla) = -\nabla^2\backslash(d\omega+\partial\omega)\ominus\nabla = -\nabla\backslash\omega\ominus\nabla$</span>. Hence, reflection by hyperplane <span>$\star\nabla$</span> has isometry <span>$\omega\oslash\nabla$</span> which is a versor outermorphism.</p><p><strong>Theorem</strong> (Cartan-Dieudonne). Every isometry of <span>$V\rightarrow V$</span> is the composite of at most <span>$k$</span> reflections across non-singular hyperplanes. Hence there exist vectors <span>$\nabla_j$</span> such that</p><div>\[(((\omega\oslash\nabla_1)\oslash\nabla_2)\oslash\cdots)\oslash\nabla_k = \omega\oslash(\nabla_1\ominus\nabla_2\ominus\dots\ominus\nabla_k)\]</div><p>for any isometry element of the orthogonal group <span>$O(p,q)$</span>. Note that elements under transformations of this group preserve inner product relations. The even grade operators make up the rotational group, where each bivector isometry is a composition of two reflections.</p><p>Consider the differential equation <span>$\partial_i\epsilon_j = \epsilon_j\oslash\omega$</span> with the solution <span>$\epsilon_j(x) = \epsilon_j(0)\oslash e^{x_i\omega}$</span> where <span>$\theta =2 x_i$</span> is the parameter of the Lie group. Then for a normalized <span>$\omega$</span>,</p><div>\[e^{\theta\omega} = \sum_k \frac{(\theta\omega)^{\ominus k}}{k!} = \begin{cases} \cosh\theta+\omega\sinh\theta, &amp; \text{if } \omega^2 = 1, \\ \cos\theta + \omega\sin\theta, &amp; \text{if } \omega^2=-1, \\ 1+\theta\omega, &amp; \text{if } \omega^2=0. \end{cases}\]</div><p>Note that <span>$\nabla\oslash e^{\theta\omega/2} = \nabla \ominus e^{\theta\omega}$</span> is a double covering when using the complex numbers in the Euclidean plane.</p><p>Due to <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes.jl</a> <code>Point</code> interoperability, plotting and visualizing with <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> is easily possible. For example, the <code>vectorfield</code> method creates an anonymous <code>Point</code> function that applies a versor outermorphism:</p><pre><code class="language-julia">using Grassmann, Makie
basis&quot;2&quot; # Euclidean
streamplot(vectorfield(exp(π*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(exp((π/2)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(v1*exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)
@basis S&quot;+-&quot; # Hyperbolic
streamplot(vectorfield(exp((π/8)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(v1*exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-1.png" alt="paper/img/plane-1.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-2.png" alt="paper/img/plane-2.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-3.png" alt="paper/img/plane-3.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-4.png" alt="paper/img/plane-4.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-5.png" alt="paper/img/plane-3.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-6.png" alt="paper/img/plane-4.png"/></p><pre><code class="language-julia">using Grassmann, Makie
@basis S&quot;∞+++&quot;
f(t) = (↓(exp(π*t*((3/7)*v12+v∞3))&gt;&gt;&gt;↑(v1+v2+v3)))
lines(V(2,3,4).(points(f)))
@basis S&quot;∞∅+++&quot;
f(t) = (↓(exp(π*t*((3/7)*v12+v∞3))&gt;&gt;&gt;↑(v1+v2+v3)))
lines(V(3,4,5).(points(f)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/torus.png" alt="paper/img/torus.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/helix.png" alt="paper/img/helix.png"/></p><pre><code class="language-julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
streamplot(vectorfield(exp((π/4)*(v12+v∞3)),V(2,3,4)),-1.5..1.5,-1.5..1.5,-1.5..1.5,gridsize=(10,10))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orb.png" alt="paper/img/orb.png"/></p><pre><code class="language-julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
streamplot(vectorfield(exp((π/4)*(v12+v∞3)),V(2,3,4),V(1,2,3)),-1.5..1.5,-1.5..1.5,-1.5..1.5,gridsize=(10,10))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/wave.png" alt="paper/img/wave.png"/></p><pre><code class="language-julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
f(t) = ↓(exp(t*v∞*(sin(3t)*3v1+cos(2t)*7v2-sin(5t)*4v3)/2)&gt;&gt;&gt;↑(v1+v2-v3))
lines(V(2,3,4).(points(f)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orbit-2.png" alt="paper/img/orb.png"/></p><pre><code class="language-julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
f(t) = ↓(exp(t*(v12+0.07v∞*(sin(3t)*3v1+cos(2t)*7v2-sin(5t)*4v3)/2))&gt;&gt;&gt;↑(v1+v2-v3))
lines(V(2,3,4).(points(f)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orbit-4.png" alt="paper/img/orb.png"/></p><p>As a result of Grassmann&#39;s exterior &amp; interior products, the Hodge-DeRahm chain complex from cohomology theory has dimensional equivalence brought by the Grassmann-Poincare-Hodge complement duality,</p><div>\[\mathcal H^{n-p}M \cong \frac{\text{ker}(d\Omega^{n-p}M)}{\text{im}(d\Omega^{n-p+1}M)}, \qquad \dim\mathcal H^pM = \dim\frac{\text{ker}(\partial\Omega^pM)}{\text{im}(\partial\Omega^{p+1}M)}.\]</div><p>The rank of the grade <span>$p$</span> boundary incidence operator is</p><div>\[\text{rank}\langle\partial\langle M\rangle_{p+1}\rangle_p = \min\{\dim\langle\partial\langle M\rangle_{p+1}\rangle_p,\dim\langle M\rangle_{p+1}\}.\]</div><p>Invariant topological information can be computed using the rank of homology groups, where <span>$b_p(M)=\dim\mathcal H^pM$</span></p><div>\[b_p(M) = \dim\langle M\rangle_{p+1} - \text{rank}\langle\partial\langle M\rangle_{p+1}\rangle_p - \text{rank}\langle\partial\langle M\rangle_{p+2}\rangle_{p+1}\]</div><p>are the Betti numbers with Euler characteristic <span>$\chi(M) = \sum_p (-1)^pb_p$</span>.</p><p>Let&#39;s obtain the full <code>skeleton</code> of a simplical complex <span>$\Delta(\omega)=\mathcal P(\omega)\backslash\Lambda^0(V)$</span> from the power set <span>$\mathcal P(\omega)$</span> of all vertices with each <code>subcomplex</code> <span>$\Delta(\partial(\omega))$</span> contained in the edge graph:</p><div>\[\Delta(\omega) =  \sum_{g=1}^n\sum_{k=1}^{n\choose g}\left(\text{abs}\langle\omega\rangle_{g,k} + \Delta\left(\text{abs}\,\partial\langle\omega\rangle_{g,k}\right)\right).\]</div><p>Compute the value <span>$\chi(\Delta(\omega))=1$</span> and <span>$\chi(\Delta(\partial(\omega))) = \, ?$</span> for any <code>Simplex</code> <span>$\omega$</span>. As an exercise, also compute the corresponding <code>betti</code> numbers..</p><pre><code class="language-julia-repl">julia&gt; [(χ(Δ(ω)),χ(Δ(∂(ω)))) for ω ∈ (Λ(5).v12,Λ(5).v123,Λ(5).v1234,Λ(5).v12345)]
4-element Array{Tuple{Int64,Int64},1}:
 (1, 2)
 (1, 0)
 (1, 2)
 (1, 0)</code></pre><p>These methods can be applied to any <code>MultiVector</code> simplicial complex.</p><h2 id="Null-basis-of-the-projective-split-1"><a class="docs-heading-anchor" href="#Null-basis-of-the-projective-split-1">Null-basis of the projective split</a><a class="docs-heading-anchor-permalink" href="#Null-basis-of-the-projective-split-1" title="Permalink"></a></h2><p>Let <span>$v_\pm^2 = \pm1$</span> be a basis with <span>$v_\infty = v_++v_-$</span> and <span>$v_\emptyset = (v_--v_+)/2$</span> An embedding space <span>$\mathbb R^{p+1,q+1}$</span> carrying the action from the group <span>$O(p+1,q+1)$</span> then has <span>$v_\infty^2 =0$</span>, <span>$v_\emptyset^2 =0$</span>, <span>$v_\infty \cdot v_\emptyset = 1$</span>,  and <span>$v_{\infty\emptyset}^2 = 1$</span> with Minkowski plane <span>$v_{\infty\emptyset}$</span> having the Hestenes-Dirac-Clifford product properties,</p><pre><code class="language-julia-repl">julia&gt; using Grassmann; @basis S&quot;∞∅++&quot;
(⟨∞∅++⟩, v, v∞, v∅, v₁, v₂, v∞∅, v∞₁, v∞₂, v∅₁, v∅₂, v₁₂, v∞∅₁, v∞∅₂, v∞₁₂, v∅₁₂, v∞∅₁₂)

julia&gt; v∞^2, v∅^2, v1^2, v2^2
(0v, 0v, 1v, 1v)

julia&gt; v∞ ⋅ v∅, v∞∅^2
(-1v, 1v)

julia&gt; v∞∅ * v∞, v∞∅ * v∅
(-1v∞, 1v∅)

julia&gt; v∞ * v∅, v∅ * v∞
(-1 + 1v∞∅, -1 - 1v∞∅)</code></pre><p>For the null-basis, complement operations are different:</p><div>\[\star v_\infty = \star(v_++v_-) = (v_- + v_+)v_{1...n} = v_{\infty1...n}\]</div><div>\[ \star 2v_\emptyset = \star(v_--v_+) = (v_+ - v_-)v_{1...n} = -2v_{\emptyset1...n}\]</div><p>The Hodge complement satisfies <span>$\langle\omega\ast\omega\rangle I=\omega\wedge\star\omega$</span>. This property is naturally a result of using the geometric product in the definition. An additional metric independent version of the complement operation is available with the <code>!</code> operator,</p><div>\[!v_\infty = !(v_++v_-) = (v_- - v_+)v_{1...n} = 2v_{\emptyset1...n}\]</div><div>\[!2v_\emptyset = !(v_--v_+) = (v_+ + v_-)v_{1...n} = -v_{\infty1...n}\]</div><p>For that variation of complement, <span>$||\omega||^2 I = \omega\,\wedge\,!\omega$</span> holds.</p><pre><code class="language-julia-repl">julia&gt; ⋆v∞, !v∞, ⋆v∅, !v∅
(1v∞₁₂, 1v∅₁₂, -1v∅₁₂, -1v∞₁₂)

julia&gt; !v∞ * v12 == -2v∅, !v∅ * v12 == v∞/2
(false, false)

julia&gt; ⋆v∞ * v12 == -v∞, ⋆v∅ * v12 == v∅
(true, true)

julia&gt; v∞ * !v∞, v∅ * !v∅
(0 - 1v₁₂ + 1v∞∅₁₂, 0 + 1v₁₂ + 1v∞∅₁₂)</code></pre><p>In this example, the null-basis properties from the projective split are shown.</p><pre><code class="language-julia-repl">julia&gt; tangent(S&quot;∞∅++&quot;,2,4)(∇^2)
0 + 1∂₃∂₃ + 1∂₄∂₄ - 2∂₁₂</code></pre><h2 id="Differential-forms-and-tangent-algebra-1"><a class="docs-heading-anchor" href="#Differential-forms-and-tangent-algebra-1">Differential forms and tangent algebra</a><a class="docs-heading-anchor-permalink" href="#Differential-forms-and-tangent-algebra-1" title="Permalink"></a></h2><p><strong>Definition</strong> (Symmetric Leibniz differentials): Let <span>$\partial_k = \frac\partial{\partial x_k}\in L_gV\,$</span> be Leibnizian symmetric tensors, then there is an equivalence relation <span>$\asymp$</span> which holds for each <span>$\sigma\in S_p$</span></p><div>\[(\partial_p \circ \dots\circ  \partial_1)\omega \asymp(\bigotimes_k \partial_{\sigma(k)})\omega  \iff \ominus_k\partial_k = \bigodot_k\partial_k,\]</div><p>along with each derivation <span>$\partial_k(\omega\eta) = \partial_k(\omega)\eta + \omega\partial_k(\eta)$</span>.</p><p>The product rule is encoded into <code>Grassmann</code> algebra when a <code>tangent</code> bundle is used, demonstrated here symbolically with <code>Reduce</code> by using the dual number definition:</p><pre><code class="language-julia">julia&gt; using Grassmann, Reduce
Reduce (Free CSL version, revision 4590), 11-May-18 ...

julia&gt; @mixedbasis tangent(ℝ^1)
(⟨+-₁¹⟩*, v, v₁, w¹, ϵ₁, ∂¹, v₁w¹, v₁ϵ₁, v₁∂¹, w¹ϵ₁, w¹∂¹, ϵ₁∂¹, v₁w¹ϵ₁, v₁w¹∂¹, v₁ϵ₁∂¹, w¹ϵ₁∂¹, v₁w¹ϵ₁∂¹)

julia&gt; a,b = :x*v1 + :dx*ϵ1, :y*v1 + :dy*ϵ1
(xv₁ + dxϵ₁, yv₁ + dyϵ₁)

julia&gt; a * b
x * y + (dy * x + dx * y)v₁ϵ₁</code></pre><p>Higher order and multivariable Taylor numbers are also supported.</p><pre><code class="language-julia-repl">julia&gt; @basis tangent(ℝ,2,2) # 1D Grade, 2nd Order, 2 Variables
(T²⟨+₁₂⟩, v, v₁, ∂₁, ∂₂, ∂₁v₁, ∂₂v₁, ∂₁₂, ∂₁₂v₁)

julia&gt; ∂1 * ∂1v1
∂₁∂₁v₁

julia&gt; ∂1 * ∂2
∂₁₂

julia&gt; v1*∂12
∂₁₂v₁

julia&gt; ∂12*∂2 # 3rd order is zero
0v

julia&gt; @mixedbasis tangent(ℝ^2,2,2); # 2D Grade, 2nd Order, 2 Variables

julia&gt; V(∇) # vector field
0v₁₂ + 1∂₁v₁ + 0∂₂v₁ + 0∂₁v₂ + 1∂₂v₂ + 0∂₁₂

julia&gt; V(∇) ⋅ V(∇) # Laplacian
0 + 1∂₁∂₁ + 1∂₂∂₂

julia&gt; ans*∂1 # 3rd order is zero
0.0v⃖</code></pre><p>Multiplication with an <span>$\epsilon_i$</span> element is used help signify tensor fields so that differential operators are automatically applied in the <code>SubManifold</code> algebra as ∂ⱼ⊖(ω⊗ϵᵢ) = ∂ⱼ(ωϵᵢ) ≠ (∂ⱼ⊗ω)⊖ϵᵢ.</p><pre><code class="language-julia">julia&gt; using Reduce, Grassmann; @mixedbasis tangent(ℝ^2,3,2);

julia&gt; (∂1+∂12) * (:(x1^2*x2^2)*ϵ1 + :(sin(x1))*ϵ2)
0.0 + (2 * x1 * x2 ^ 2)∂₁ϵ¹ + (cos(x1))∂₁ϵ² + (4 * x1 * x2)∂₁₂ϵ¹</code></pre><p>Although fully generalized, the implementation in this release is still experimental.</p><h2 id="Symbolic-coefficients-by-declaring-algebra-1"><a class="docs-heading-anchor" href="#Symbolic-coefficients-by-declaring-algebra-1">Symbolic coefficients by declaring algebra</a><a class="docs-heading-anchor-permalink" href="#Symbolic-coefficients-by-declaring-algebra-1" title="Permalink"></a></h2><p>Due to the abstract generality of the code generation of the <code>Grassmann</code> product algebra, it is easily possible to extend the entire set of operations to other kinds of scalar coefficient types.</p><pre><code class="language-julia">julia&gt; using GaloisFields, Grassmann

julia&gt; const F = GaloisField(7)
𝔽₇

julia&gt; basis&quot;2&quot;
(⟨++⟩, v, v₁, v₂, v₁₂)

julia&gt; F(3)*v1
3v₁

julia&gt; inv(ans)
5v₁</code></pre><p>By default, the coefficients are required to be <code>&lt;:Number</code>. However, if this does not suit your needs, alternative scalar product algebras can be specified with</p><pre><code class="language-julia">Grassmann.generate_algebra(:AbstractAlgebra,:SetElem)</code></pre><p>where <code>:SetElem</code> is the desired scalar field and <code>:AbstractAlgebra</code> is the scope which contains the scalar field.</p><p>With the usage of <code>Requires</code>, symbolic scalar computation with <a href="https://github.com/chakravala/Reduce.jl">Reduce.jl</a> and other packages is automatically enabled,</p><pre><code class="language-julia">julia&gt; using Reduce, Grassmann
Reduce (Free CSL version, revision 4590), 11-May-18 ...

julia&gt; basis&quot;2&quot;
(⟨++⟩, v, v₁, v₂, v₁₂)

julia&gt; (:a*v1 + :b*v2) ⋅ (:c*v1 + :d*v2)
(a * c + b * d)v

julia&gt; (:a*v1 + :b*v2) ∧ (:c*v1 + :d*v2)
0.0 + (a * d - b * c)v₁₂

julia&gt; (:a*v1 + :b*v2) * (:c*v1 + :d*v2)
a * c + b * d + (a * d - b * c)v₁₂</code></pre><p>If these compatibility steps are followed, then <code>Grassmann</code> will automatically declare the product algebra to use the <code>Reduce.Algebra</code> symbolic field operation scope.</p><pre><code class="language-julia">julia&gt; using Reduce,Grassmann; basis&quot;4&quot;
Reduce (Free CSL version, revision 4590), 11-May-18 ...
(⟨++++⟩, v, v₁, v₂, v₃, v₄, v₁₂, v₁₃, v₁₄, v₂₃, v₂₄, v₃₄, v₁₂₃, v₁₂₄, v₁₃₄, v₂₃₄, v₁₂₃₄)

julia&gt; P,Q = :px*v1 + :py*v2 + :pz* v3 + v4, :qx*v1 + :qy*v2 + :qz*v3 + v4
(pxv₁ + pyv₂ + pzv₃ + 1.0v₄, qxv₁ + qyv₂ + qzv₃ + 1.0v₄)

julia&gt; P∧Q
0.0 + (px * qy - py * qx)v₁₂ + (px * qz - pz * qx)v₁₃ + (px - qx)v₁₄ + (py * qz - pz * qy)v₂₃ + (py - qy)v₂₄ + (pz - qz)v₃₄

julia&gt; R = :rx*v1 + :ry*v2 + :rz*v3 + v4
rxv₁ + ryv₂ + rzv₃ + 1.0v₄

julia&gt; P∧Q∧R
0.0 + ((px * qy - py * qx) * rz - ((px * qz - pz * qx) * ry - (py * qz - pz * qy) * rx))v₁₂₃ + (((px * qy - py * qx) + (py - qy) * rx) - (px - qx) * ry)v₁₂₄ + (((px * qz - pz * qx) + (pz - qz) * rx) - (px - qx) * rz)v₁₃₄ + (((py * qz - pz * qy) + (pz - qz) * ry) - (py - qy) * rz)v₂₃₄</code></pre><p>It should be straight-forward to easily substitute any other extended algebraic operations and fields; issues with questions or pull-requests to that end are welcome.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><a class="docs-footer-nextpage" href="../library/">Library »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 30 April 2020 04:54">Thursday 30 April 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
