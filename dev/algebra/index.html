<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algebra · Grassmann.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Grassmann.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Algebra</a><ul class="internal"><li><a class="tocitem" href="#Approaching-dimensions-with-SparseAlgebra-and-ExtendedAlgebra-1"><span>Approaching ∞ dimensions with <code>SparseAlgebra</code> and <code>ExtendedAlgebra</code></span></a></li><li><a class="tocitem" href="#Null-basis-of-the-projective-split-1"><span>Null-basis of the projective split</span></a></li><li><a class="tocitem" href="#Differential-forms-and-Leibniz-tangent-algebra-1"><span>Differential forms and Leibniz tangent algebra</span></a></li><li><a class="tocitem" href="#Symbolic-coefficients-by-declaring-an-alternative-scalar-algebra-1"><span>Symbolic coefficients by declaring an alternative scalar algebra</span></a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/quick-start/">Quick start (G2)</a></li><li><a class="tocitem" href="../tutorials/algebra-of-space/">The Algebra of Space (G3)</a></li><li><a class="tocitem" href="../tutorials/forms/">-</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Grassmann.jl/blob/master/docs/src/algebra.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Grassmann-elements-and-geometric-algebra-Λ(V)-1"><a class="docs-heading-anchor" href="#Grassmann-elements-and-geometric-algebra-Λ(V)-1">Grassmann elements and geometric algebra Λ(V)</a><a class="docs-heading-anchor-permalink" href="#Grassmann-elements-and-geometric-algebra-Λ(V)-1" title="Permalink"></a></h1><p>The Grassmann <code>Basis</code> elements <code>vₖ</code> and <code>wᵏ</code> are linearly independent vector and covector elements of <code>V</code>, while the Leibniz <code>Operator</code> elements <code>∂ₖ</code> are partial tangent derivations and <code>ϵᵏ</code> are dependent functions of the <code>tangent</code> manifold. Higher <code>grade</code> elements correspond to <code>SubManifold</code> subspaces, while higher <code>order</code> function elements become homogenous polynomials and Taylor series.</p><p>Combining the linear basis generating elements with each other using the multilinear tensor product yields a graded (decomposable) tensor <code>Basis</code> ⟨w₁⊗⋯⊗wₖ⟩, where <code>grade</code> is determined by the number of anti-symmetric basis elements in its tensor product decomposition. The algebra is partitioned into both symmetric and anti-symmetric tensor equivalence classes. Higher-order composite tensor elements are oriented-multi-sets. Anti-symmetric indices have two orientations and higher multiplicities of them result in zero values, so the only interesting multiplicity is 1. The Leibniz-Taylor algebra is a quotient polynomial ring  so that <code>ϵₖ^(μ+1)</code> is zero.</p><p>By virtue of Julia&#39;s multiple dispatch on the field type <code>T</code>, methods can specialize on the dimension <code>N</code> and grade <code>G</code> with a <code>VectorBundle{N}</code> via the <code>TensorAlgebra{V}</code> subtypes, such as <code>Basis{V,G}</code>, <code>Simplex{V,G,B,T}</code>, <code>Chain{V,G,T}</code>, <code>SparseChain{V,G,T}</code>, <code>MultiVector{V,T}</code>, and <code>MultiGrade{V,G}</code> types.</p><p>For the oriented sets of the Grassmann exterior algebra, the parity of <code>(-1)^P</code> is factored into transposition compositions when interchanging ordering of the tensor product argument permutations. The symmetrical algebra does not need to track this parity, but has higher multiplicities in its indices. Symmetric differential function algebra of Leibniz trivializes the orientation into a single class of index multi-sets, while Grassmann&#39;s exterior algebra is partitioned into two oriented equivalence classes by anti-symmetry. Full tensor algebra can be sub-partitioned into equivalence classes in multiple ways based on the element symmetry, grade, and metric signature composite properties. Both symmetry classes can be characterized by the same geometric product.</p><p>Grassmann&#39;s exterior algebra doesn&#39;t invoke the properties of multi-sets, as it is related to the algebra of oriented sets; while the Leibniz symmetric algebra is that of unoriented multi-sets. Combined, the mixed-symmetry algebra yield a multi-linear propositional lattice. The formal sum of equal <code>grade</code> elements is an oriented <code>Chain</code> and with mixed <code>grade</code> it is a <code>MultiVector</code> simplicial complex. Thus, various standard operations on the oriented multi-sets are possible including <code>∪,∩,⊕</code> and the index operation <code>⊖</code>, which is symmetric difference operation <code>⊻</code>.</p><p>The elements of the <code>Algebra</code> can be generated in many ways using the <code>Basis</code> elements created by the <code>@basis</code> macro,</p><pre><code class="language-Julia">julia&gt; using Grassmann; @basis ℝ&#39;⊕ℝ^3 # equivalent to basis&quot;-+++&quot;
(⟨-+++⟩, v, v₁, v₂, v₃, v₄, v₁₂, v₁₃, v₁₄, v₂₃, v₂₄, v₃₄, v₁₂₃, v₁₂₄, v₁₃₄, v₂₃₄, v₁₂₃₄)</code></pre><p>As a result of this macro, all of the <code>Basis{V,G}</code> elements generated by that <code>VectorBundle</code> become available in the local workspace with the specified naming. The first argument provides signature specifications, the second argument is the variable name for the <code>VectorBundle</code>, and the third and fourth argument are the the prefixes of the <code>Basis</code> vector names (and covector basis names). By default, <code>V</code> is assigned the <code>VectorBundle</code> and <code>v</code> is the prefix for the <code>Basis</code> elements.</p><pre><code class="language-Julia">julia&gt; V # Minkowski spacetime
⟨-+++⟩

julia&gt; typeof(V) # dispatch by vector space
VectorBundle{4,0,0x0000000000000001}

julia&gt; typeof(v13) # extensive type info
Basis{⟨-+++⟩,2,0x0000000000000005}

julia&gt; v13∧v2 # exterior tensor product
-1v₁₂₃

julia&gt; ans^2 # applies geometric product
1v

julia&gt; @btime 2v1+v3 # vector element
  37.794 ns (3 allocations: 80 bytes)
2v₁ + 0v₂ + 1v₃ + 0v₄

julia&gt; @btime $ans⋅$ans # inner product
  15.266 ns (3 allocations: 48 bytes)
-3v</code></pre><p>It is entirely possible to assign multiple different bases with different signatures without any problems. In the following command, the <code>@basis</code> macro arguments are used to assign the vector space name to <code>S</code> instead of <code>V</code> and basis elements to <code>b</code> instead of <code>v</code>, so that their local names do not interfere:</p><pre><code class="language-Julia">julia&gt; @basis &quot;++++&quot; S b;

julia&gt; let k = (b1+b2)-b3
           for j ∈ 1:9
               k = k*(b234+b134)
               println(k)
       end end
0 + 1v₁₄ + 1v₂₄ + 2v₃₄
0 - 2v₁ - 2v₂ + 2v₃
0 - 2v₁₄ - 2v₂₄ - 4v₃₄
0 + 4v₁ + 4v₂ - 4v₃
0 + 4v₁₄ + 4v₂₄ + 8v₃₄
0 - 8v₁ - 8v₂ + 8v₃
0 - 8v₁₄ - 8v₂₄ - 16v₃₄
0 + 16v₁ + 16v₂ - 16v₃
0 + 16v₁₄ + 16v₂₄ + 32v₃₄</code></pre><p>Alternatively, if you do not wish to assign these variables to your local workspace, the versatile <code>Grassmann.Algebra{N}</code> constructors can be used to contain them, which is exported to the user as the method <code>Λ(V)</code>,</p><pre><code class="language-Julia">julia&gt; G3 = Λ(3) # equivalent to Λ(V&quot;+++&quot;), Λ(ℝ^3), Λ.V3
Grassmann.Algebra{⟨+++⟩,8}(v, v₁, v₂, v₃, v₁₂, v₁₃, v₂₃, v₁₂₃)

julia&gt; G3.v13 * G3.v12
v₂₃</code></pre><p>The <em>geometric algebraic product</em> is the oriented symmetric difference operator <code>⊖</code> (weighted by the bilinear form <code>g</code>) and multi-set sum <code>⊕</code> applied to multilinear tensor products <code>⊗</code> in a single operation. Symmetry properties of the tensor algebra can be characterized in terms of the geometric product by two averaging operations, which are the symmetrization <code>⊙</code> and anti-symmetrization <code>⊠</code> operators. These products satisfy various <code>MultiVector</code> properties, including the associative and distributive laws.</p><p>It is possible to assign the <strong>quaternion</strong> generators <code>i,j,k</code> with</p><pre><code class="language-Julia">julia&gt; i,j,k = hyperplanes(ℝ^3)
3-element Array{Simplex{⟨+++⟩,2,B,Int64} where B,1}:
 -1v₂₃
 1v₁₃
 -1v₁₂

julia&gt; @btime $i^2, $j^2, $k^2, $i*$j*$k
  0.027 ns (0 allocations: 0 bytes)
(-1v, -1v, -1v, -1v)

julia&gt; @btime -(j+k) * (j+k)
  97.373 ns (4 allocations: 176 bytes)
2.0v⃖

julia&gt; @btime -(j+k) * i
  67.695 ns (3 allocations: 144 bytes)
0.0 - 1.0v₁₂ - 1.0v₁₃</code></pre><p>Alternatively, another representation of the quaternions is</p><pre><code class="language-Julia">julia&gt; basis&quot;--&quot;
(⟨--⟩, v, v₁, v₂, v₁₂)

julia&gt; v1^2, v2^2, v12^2, v1*v2*v12
(-1v, -1v, -1v, -1v)</code></pre><p>With the preliminary implementations of the <code>exp</code> and <code>log</code> functions one can compute</p><pre><code class="language-Julia">julia&gt; exp(0.5π/2*(i+j)/sqrt(2))
0.7071067811865476 + 0.5v₁₃ - 0.5v₂₃

julia&gt; ans == (sqrt(2)+j+i)/2
true

julia&gt; log1p(i)
0.34657359027997264 - 0.7853981633974485v₂₃

julia&gt; log(i)
0.0 - 1.5708963467978978v₂₃</code></pre><p>The parametric type formalism in <code>Grassmann</code> is highly expressive to enable the pre-allocation of geometric algebra computations for specific sparse-subalgebras, including the representation of rotational groups, Lie bivector algebras, and affine projective geometry.</p><p>Together with <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs,jl</a>, <a href="https://github.com/JuliaGraphs/GraphPlot.jl">GraphPlot.jl</a>, <a href="https://github.com/JuliaGraphics/Cairo.jl">Cairo.jl</a>, <a href="https://github.com/GiovineItalia/Compose.jl">Compose.jl</a> it is possible to convert <code>Grassmann</code> numbers into graphs.</p><pre><code class="language-Julia">using Grassmann, Compose # environment: LightGraphs, GraphPlot
x = Grassmann.Algebra(ℝ^7).v123
Grassmann.graph(x+!x)
draw(PDF(&quot;simplex.pdf&quot;,16cm,16cm),x+!x)</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/triangle-tetrahedron.png" alt="paper/img/triangle-tetrahedron.png"/></p><p>Due to <a href="https://github.com/JuliaGeometry/GeometryTypes.jl">GeometryTypes,jl</a> <code>Point</code> interoperability, plotting and visualizing with <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> is easily possible. For example, the <code>vectorfield</code> method creates an anonymous <code>Point</code> function that applies a versor outermorphism:</p><pre><code class="language-Julia">using Grassmann, Makie
basis&quot;2&quot; # Euclidean
streamplot(vectorfield(exp(π*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(exp((π/2)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(v1*exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)
@basis S&quot;+-&quot; # Hyperbolic
streamplot(vectorfield(exp((π/8)*v12/2)),-1.5..1.5,-1.5..1.5)
streamplot(vectorfield(v1*exp((π/4)*v12/2)),-1.5..1.5,-1.5..1.5)</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-1.png" alt="paper/img/plane-1.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-2.png" alt="paper/img/plane-2.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-3.png" alt="paper/img/plane-3.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-4.png" alt="paper/img/plane-4.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-5.png" alt="paper/img/plane-3.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/plane-6.png" alt="paper/img/plane-4.png"/></p><pre><code class="language-Julia">using Grassmann, Makie
@basis S&quot;∞+++&quot;
f(t) = (↓(exp(π*t*((3/7)*v12+v∞3))&gt;&gt;&gt;↑(v1+v2+v3)))
lines(points(f,V(2,3,4)))
@basis S&quot;∞∅+++&quot;
f(t) = (↓(exp(π*t*((3/7)*v12+v∞3))&gt;&gt;&gt;↑(v1+v2+v3)))
lines(points(f,V(3,4,5)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/torus.png" alt="paper/img/torus.png"/> <img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/helix.png" alt="paper/img/helix.png"/></p><pre><code class="language-Julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
streamplot(vectorfield(exp((π/4)*(v12+v∞3)),V(2,3,4)),-1.5..1.5,-1.5..1.5,-1.5..1.5,gridsize=(10,10))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orb.png" alt="paper/img/orb.png"/></p><pre><code class="language-Julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
streamplot(vectorfield(exp((π/4)*(v12+v∞3)),V(2,3,4),V(1,2,3)),-1.5..1.5,-1.5..1.5,-1.5..1.5,gridsize=(10,10))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/wave.png" alt="paper/img/wave.png"/></p><pre><code class="language-Julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
f(t) = ↓(exp(t*v∞*(sin(3t)*3v1+cos(2t)*7v2-sin(5t)*4v3)/2)&gt;&gt;&gt;↑(v1+v2-v3))
lines(points(f,V(2,3,4)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orbit-2.png" alt="paper/img/orb.png"/></p><pre><code class="language-Julia">using Grassmann, Makie; @basis S&quot;∞+++&quot;
f(t) = ↓(exp(t*(v12+0.07v∞*(sin(3t)*3v1+cos(2t)*7v2-sin(5t)*4v3)/2))&gt;&gt;&gt;↑(v1+v2-v3))
lines(points(f,V(2,3,4)))</code></pre><p><img src="https://raw.githubusercontent.com/chakravala/Grassmann.jl/master/paper/img/orbit-4.png" alt="paper/img/orb.png"/></p><h2 id="Approaching-dimensions-with-SparseAlgebra-and-ExtendedAlgebra-1"><a class="docs-heading-anchor" href="#Approaching-dimensions-with-SparseAlgebra-and-ExtendedAlgebra-1">Approaching ∞ dimensions with <code>SparseAlgebra</code> and <code>ExtendedAlgebra</code></a><a class="docs-heading-anchor-permalink" href="#Approaching-dimensions-with-SparseAlgebra-and-ExtendedAlgebra-1" title="Permalink"></a></h2><p>In order to work with a <code>TensorAlgebra{V}</code>, it is necessary for some computations to be cached. This is usually done automatically when accessed.</p><pre><code class="language-Julia">julia&gt; Λ(7) + Λ(7)&#39;
Grassmann.SparseAlgebra{⟨+++++++-------⟩*,16384}(v, ..., v₁₂₃₄₅₆₇w¹²³⁴⁵⁶⁷)</code></pre><p>One way of declaring the cache for all 3 combinations of a <code>VectorBundle{N}</code> and its dual is to ask for the sum <code>Λ(V) + Λ(V)&#39;</code>, which is equivalent to <code>Λ(V⊕V&#39;)</code>, but this does not initialize the cache of all 3 combinations unlike the former.</p><p>Staging of precompilation and caching is designed so that a user can smoothly transition between very high dimensional and low dimensional algebras in a single session, with varying levels of extra caching and optimizations. The parametric type formalism in <code>Grassmann</code> is highly expressive and enables pre-allocation of geometric algebra computations involving specific sparse subalgebras, including the representation of rotational groups.</p><p>It is possible to reach <code>Simplex</code> elements with up to <code>N=62</code> vertices from a <code>TensorAlgebra</code> having higher maximum dimensions than supported by Julia natively.</p><pre><code class="language-Julia">julia&gt; Λ(62)
Grassmann.ExtendedAlgebra{⟨++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++⟩,4611686018427387904}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ)

julia&gt; Λ(62).v32a87Ng
-1v₂₃₇₈agN</code></pre><p>The 62 indices require full alpha-numeric labeling with lower-case and capital letters. This now allows you to reach up to <code>4,611,686,018,427,387,904</code> dimensions with Julia <code>using Grassmann</code>. Then the volume element is</p><pre><code class="language-Julia">v₁₂₃₄₅₆₇₈₉₀abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>Full <code>MultiVector</code> allocations are only possible for <code>N≤22</code>, but sparse operations are also available at higher dimensions. While <code>Grassmann.Algebra{V}</code> is a container for the <code>TensorAlgebra</code> generators of <code>V</code>, the <code>Grassmann.Algebra</code> is only cached for <code>N≤8</code>. For the range of dimensions <code>8&lt;N≤22</code>$, the <code>Grassmann.SparseAlgebra</code> type is used.</p><pre><code class="language-Julia">julia&gt; Λ(22)
Grassmann.SparseAlgebra{⟨++++++++++++++++++++++⟩,4194304}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijkl)</code></pre><p>This is the largest <code>SparseAlgebra</code> that can be generated with Julia, due to array size limitations.</p><p>To reach higher dimensions with <code>N&gt;22</code>, the <code>Grassmann.ExtendedAlgebra</code> type is used. It is suficient to work with a 64-bit representation (which is the default). And it turns out that with 62 standard keyboard characters, this fits nicely.</p><pre><code class="language-Julia">julia&gt; V = ℝ^22
⟨++++++++++++++++++++++⟩

julia&gt; Λ(V+V&#39;)
Grassmann.ExtendedAlgebra{⟨++++++++++++++++++++++----------------------⟩*,17592186044416}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijklw¹²³⁴⁵⁶⁷⁸⁹⁰ABCDEFGHIJKL)</code></pre><p>At 22 dimensions and lower there is better caching, with further extra caching for 8 dimensions or less. Thus, the largest Hilbert space that is fully reachable has 4,194,304 dimensions, but we can still reach out to 4,611,686,018,427,387,904 dimensions with the <code>ExtendedAlgebra</code> built in. It is still feasible to extend to a further super-extended 128-bit representation using the <code>UInt128</code> type (but this will require further modifications of internals and helper functions. To reach into infinity even further, it is theoretically possible to construct ultra-extensions also using dictionaries. Full <code>MultiVector</code> elements are not representable when <code>ExtendedAlgebra</code> is used, but the performance of the <code>Basis</code> and sparse elements should be just as fast as for lower dimensions for the current <code>SubAlgebra</code> and <code>TensorAlgebra</code> types. The sparse representations are a work in progress to be improved with time.</p><h2 id="Null-basis-of-the-projective-split-1"><a class="docs-heading-anchor" href="#Null-basis-of-the-projective-split-1">Null-basis of the projective split</a><a class="docs-heading-anchor-permalink" href="#Null-basis-of-the-projective-split-1" title="Permalink"></a></h2><p>In the following example, the null-basis from the projective split is used:</p><pre><code class="language-Julia">julia&gt; using Grassmann; @basis S&quot;∞∅++&quot;
(⟨∞∅++⟩, v, v∞, v∅, v₁, v₂, v∞∅, v∞₁, v∞₂, v∅₁, v∅₂, v₁₂, v∞∅₁, v∞∅₂, v∞₁₂, v∅₁₂, v∞∅₁₂)

julia&gt; v∞^2, v∅^2, v1^2, v2^2
(0v, 0v, v, v)

julia&gt; v∞ ⋅ v∅
-1v

julia&gt; v∞∅^2
v

julia&gt; v∞∅ * v∞, v∞∅ * v∅
(-1v∞, v∅)

julia&gt; v∞ * v∅, v∅ * v∞
(-1 + 1v∞∅, -1 - 1v∞∅)</code></pre><h2 id="Differential-forms-and-Leibniz-tangent-algebra-1"><a class="docs-heading-anchor" href="#Differential-forms-and-Leibniz-tangent-algebra-1">Differential forms and Leibniz tangent algebra</a><a class="docs-heading-anchor-permalink" href="#Differential-forms-and-Leibniz-tangent-algebra-1" title="Permalink"></a></h2><p>Multiplication with an <code>ϵᵢ</code> element is used help signify tensor fields so that differential operators are automatically applied in the <code>Basis</code> algebra as ∂ⱼ⊖(ω⊗ϵᵢ) = ∂ⱼ(ωϵᵢ) ≠ (∂ⱼ⊗ω)⊖ϵᵢ.</p><pre><code class="language-Julia">julia&gt; using Reduce, Grassmann; @mixedbasis tangent(ℝ^2,3,2);

julia&gt; (∂1+∂12) * (:(x1^2*x2^2)*ϵ1 + :(sin(x1))*ϵ2)
0.0 + (2 * x1 * x2 ^ 2)∂₁ϵ¹ + (cos(x1))∂₁ϵ² + (4 * x1 * x2)∂₁₂ϵ¹</code></pre><p>The product rule is encoded into <code>Grassmann</code> algebra when a <code>tangent</code> bundle is used, demonstrated here symbolically with <code>Reduce</code> by using the dual number definition:</p><pre><code class="language-Julia">julia&gt; using Grassmann, Reduce
Reduce (Free CSL version, revision 4590), 11-May-18 ...

julia&gt; @mixedbasis tangent(ℝ^1)
(⟨+-₁¹⟩*, v, v₁, w¹, ϵ₁, ∂¹, v₁w¹, v₁ϵ₁, v₁∂¹, w¹ϵ₁, w¹∂¹, ϵ₁∂¹, v₁w¹ϵ₁, v₁w¹∂¹, v₁ϵ₁∂¹, w¹ϵ₁∂¹, v₁w¹ϵ₁∂¹)

julia&gt; a,b = :x*v1 + :dx*ϵ1, :y*v1 + :dy*ϵ1
(xv₁ + dxϵ₁, yv₁ + dyϵ₁)

julia&gt; a * b
x * y + (dy * x + dx * y)v₁ϵ₁</code></pre><p>Higher order and multivariable Taylor numbers are also supported.</p><pre><code class="language-Julia">julia&gt; @basis tangent(ℝ,2,2) # 1D Grade, 2nd Order, 2 Variables
(⟨+₁₂⟩, v, v₁, ∂₁, ∂₂, ∂₁v₁, ∂₂v₁, ∂₁₂, ∂₁₂v₁)

julia&gt; ∂1 * ∂1v1
∂₁∂₁v₁

julia&gt; ∂1 * ∂2
∂₁₂

julia&gt; v1*∂12
∂₁₂v₁

julia&gt; ∂12*∂2 # 3rd order is zero
0v

julia&gt; @mixedbasis tangent(ℝ^2,2,2); # 2D Grade, 2nd Order, 2 Variables

julia&gt; ∇ = ∂1v1 + ∂2v2 # vector field
0v₁₂ + 1∂₁v₁ + 0∂₂v₁ + 0∂₁v₂ + 1∂₂v₂ + 0∂₁₂

julia&gt; ∇ ⋅ ∇ # Laplacian
0.0v₁ + 0.0v₂ + 1∂₁∂₁ + 1∂₂∂₂

julia&gt; ans*∂1 # 3rd order is zero
0.0v⃖</code></pre><p>Although fully generalized, the implementation in this release is still experimental.</p><h2 id="Symbolic-coefficients-by-declaring-an-alternative-scalar-algebra-1"><a class="docs-heading-anchor" href="#Symbolic-coefficients-by-declaring-an-alternative-scalar-algebra-1">Symbolic coefficients by declaring an alternative scalar algebra</a><a class="docs-heading-anchor-permalink" href="#Symbolic-coefficients-by-declaring-an-alternative-scalar-algebra-1" title="Permalink"></a></h2><p>Due to the abstract generality of the code generation of the <code>Grassmann</code> product algebra, it is easily possible to extend the entire set of operations to other kinds of scalar coefficient types.</p><pre><code class="language-Julia">julia&gt; using GaloisFields, Grassmann

julia&gt; const F = GaloisField(7)
𝔽₇

julia&gt; basis&quot;2&quot;
(⟨++⟩, v, v₁, v₂, v₁₂)

julia&gt; @btime F(3)*v1
  21.076 ns (2 allocations: 32 bytes)
3v₁

julia&gt; @btime inv($ans)
  14.965 ns (0 allocations: 0 bytes)
5v₁</code></pre><p>By default, the coefficients are required to be <code>&lt;:Number</code>. However, if this does not suit your needs, alternative scalar product algebras can be specified with</p><pre><code class="language-Julia">Grassmann.generate_algebra(:AbstractAlgebra,:SetElem)</code></pre><p>where <code>:SetElem</code> is the desired scalar field and <code>:AbstractAlgebra</code> is the scope which contains the scalar field.</p><p>With the usage of <code>Requires</code>, symbolic scalar computation with <a href="https://github.com/chakravala/Reduce.jl">Reduce.jl</a> and other packages is automatically enabled, e.g.</p><pre><code class="language-Julia">julia&gt; using Reduce, Grassmann
Reduce (Free CSL version, revision 4590), 11-May-18 ...

julia&gt; basis&quot;2&quot;
(⟨++⟩, v, v₁, v₂, v₁₂)

julia&gt; (:a*v1 + :b*v2) ⋅ (:c*v1 + :d*v2)
(a * c + b * d)v

julia&gt; (:a*v1 + :b*v2) ∧ (:c*v1 + :d*v2)
0.0 + (a * d - b * c)v₁₂

julia&gt; (:a*v1 + :b*v2) * (:c*v1 + :d*v2)
a * c + b * d + (a * d - b * c)v₁₂</code></pre><p>If these compatibility steps are followed, then <code>Grassmann</code> will automatically declare the product algebra to use the <code>Reduce.Algebra</code> symbolic field operation scope.</p><pre><code class="language-Julia">julia&gt; using Reduce,Grassmann; basis&quot;4&quot;
Reduce (Free CSL version, revision 4590), 11-May-18 ...
(⟨++++⟩, v, v₁, v₂, v₃, v₄, v₁₂, v₁₃, v₁₄, v₂₃, v₂₄, v₃₄, v₁₂₃, v₁₂₄, v₁₃₄, v₂₃₄, v₁₂₃₄)

julia&gt; P,Q = :px*v1 + :py*v2 + :pz* v3 + v4, :qx*v1 + :qy*v2 + :qz*v3 + v4
(pxv₁ + pyv₂ + pzv₃ + 1.0v₄, qxv₁ + qyv₂ + qzv₃ + 1.0v₄)

julia&gt; P∧Q
0.0 + (px * qy - py * qx)v₁₂ + (px * qz - pz * qx)v₁₃ + (px - qx)v₁₄ + (py * qz - pz * qy)v₂₃ + (py - qy)v₂₄ + (pz - qz)v₃₄

julia&gt; R = :rx*v1 + :ry*v2 + :rz*v3 + v4
rxv₁ + ryv₂ + rzv₃ + 1.0v₄

julia&gt; P∧Q∧R
0.0 + ((px * qy - py * qx) * rz - ((px * qz - pz * qx) * ry - (py * qz - pz * qy) * rx))v₁₂₃ + (((px * qy - py * qx) + (py - qy) * rx) - (px - qx) * ry)v₁₂₄ + (((px * qz - pz * qx) + (pz - qz) * rx) - (px - qx) * rz)v₁₃₄ + (((py * qz - pz * qy) + (pz - qz) * ry) - (py - qy) * rz)v₂₃₄</code></pre><p>It should be straight-forward to easily substitute any other extended algebraic operations and fields; issues with questions or pull-requests to that end are welcome.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><a class="docs-footer-nextpage" href="../library/">Library »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 14 December 2019 03:42">Saturday 14 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
