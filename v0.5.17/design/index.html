<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design · Grassmann.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Grassmann.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Grassmann.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Design</a><ul class="internal"><li><a class="tocitem" href="#DirectSum-yields-TensorBundle-parametric-type-polymorphism"><span>DirectSum yields <code>TensorBundle</code> parametric type polymorphism</span></a></li><li><a class="tocitem" href="#Approaching-dimensions-with-SparseBasis-and-ExtendedBasis"><span>Approaching ∞ dimensions with <code>SparseBasis</code> and <code>ExtendedBasis</code></span></a></li><li><a class="tocitem" href="#Interoperability-for-TensorAlgebra{V}"><span>Interoperability for <code>TensorAlgebra{V}</code></span></a></li></ul></li><li><a class="tocitem" href="../algebra/">Algebra</a></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../agpl/">AGPL-3.0</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/install/">Installation</a></li><li><a class="tocitem" href="../tutorials/quick-start/">Quick start (G2)</a></li><li><a class="tocitem" href="../tutorials/algebra-of-space/">The Algebra of Space (G3)</a></li><li><a class="tocitem" href="../tutorials/dyadic-tensors/">Dyadic tensor product ⊗</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chakravala/Grassmann.jl/blob/master/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TensorAlgebra-design,-Manifold-code-generation"><a class="docs-heading-anchor" href="#TensorAlgebra-design,-Manifold-code-generation"><code>TensorAlgebra</code> design, <code>Manifold</code> code generation</a><a id="TensorAlgebra-design,-Manifold-code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#TensorAlgebra-design,-Manifold-code-generation" title="Permalink"></a></h1><p>Mathematical foundations and definitions specific to the <a href="https://github.com/chakravala/Grassmann.jl">Grassmann.jl</a> implementation provide an extensible platform for computing with geometric algebra at high dimensions, along with the accompanying support packages.  The design is based on the <code>TensorAlgebra</code> abstract type interoperability from <a href="https://github.com/chakravala/AbstractTensors.jl">AbstractTensors.jl</a> with a <code>TensorBundle</code> parameter from <a href="https://github.com/chakravala/DirectSum.jl">DirectSum.jl</a>. Abstract tangent vector space type operations happen at compile-time, resulting in a differential conformal geometric algebra of hyper-dual multivector forms.</p><p>The nature of the geometric algebra code generation enables one to easily extend the abstract product operations to any specific number field type (including differential operators with <a href="https://github.com/chakravala/Leibniz.jl">Leibniz.jl</a> or symbolic coefficients with <a href="https://github.com/chakravala/Reduce.jl">Reduce.jl</a>), by making use of Julia&#39;s type system. Mixed tensor products with their coefficients are constructed from these operations to work with bivector elements of Lie groups.</p><ul><li><strong>DirectSum.jl</strong>: Abstract tangent bundle vector space types (unions, intersections, sums, etc.)</li><li><strong>AbstractTensors.jl</strong>: Tensor algebra abstract type interoperability with vector bundle parameter</li><li><strong>Grassmann.jl</strong>: ⟨Leibniz-Grassmann-Clifford-Hestenes⟩ differential geometric algebra of multivector forms</li><li><strong>Leibniz.jl</strong>: Derivation operator algebras for tensor fields</li><li><strong>Reduce.jl</strong>: Symbolic parser generator for Julia expressions using REDUCE algebra term rewriter</li></ul><p>Mathematics of <code>Grassmann</code> can be used to study unitary groups used in quantum computing by building efficient computational representations of their algebras. Applicability of the Grassmann computational package not only maps to quantum computing, but has the potential of impacting countless other engineering and scientific computing applications. It can be used to work with automatic differentiation and differential geometry, algebraic forms and invariant theory, electric circuits and wave scattering, spacetime geometry and relativity, computer graphics and photogrammetry, and much more.</p><p>Thus, computations involving fully general rotational algebras and Lie bivector groups are possible with a full trigonometric suite. Conformal geometric algebra is possible with the Minkowski plane <span>$v_{\infty\emptyset}$</span>, based on the null-basis. In general, multivalued quantum logic is enabled by the <span>$\wedge,\vee,\star$</span> Grassmann lattice. Mixed-symmetry algebra with <em>Leibniz.jl</em> and <em>Grassmann.jl</em>, having the geometric algebraic product chain rule, yields automatic differentiation and Hodge-DeRahm co/homology  as unveiled by Grassmann. Most importantly, the Dirac-Clifford product yields generalized Hodge-Laplacian and the Betti numbers with Euler characteristic <span>$\chi$</span>.</p><p>Due to the abstract generality of the product algebra code generation, it is possible to extend the <code>Grassmann</code> library to include additional high performance products with few extra definitions. Operations on ultra-sparse representations for very high dimensional algebras will be gaining further performance enhancements in future updates, along with hybrid optimizations for low-dimensional algebra code generation. Thanks to the design of the product algebra code generation, any additional optimizations to the type stability will automatically enhance all the different products simultaneously. Likewise, any new product formulas will be able to quickly gain from the setup of all of the existing optimizations.</p><p>The <em>Grassmann.jl</em> package and its accompanying support packages provide an extensible platform for high performance computing with geometric algebra at high dimensions. This enables the usage of many different types of <code>TensorAlgebra</code> along with various <code>TensorBundle</code> parameters and interoperability for a wide range of scientific and research applications.</p><h2 id="DirectSum-yields-TensorBundle-parametric-type-polymorphism"><a class="docs-heading-anchor" href="#DirectSum-yields-TensorBundle-parametric-type-polymorphism">DirectSum yields <code>TensorBundle</code> parametric type polymorphism</a><a id="DirectSum-yields-TensorBundle-parametric-type-polymorphism-1"></a><a class="docs-heading-anchor-permalink" href="#DirectSum-yields-TensorBundle-parametric-type-polymorphism" title="Permalink"></a></h2><p><a href="https://zenodo.org/badge/latestdoi/169765288"><img src="https://zenodo.org/badge/169765288.svg" alt="DOI"/></a> <a href="https://github.com/chakravala/DirectSum.jl/releases"><img src="https://img.shields.io/github/v/release/chakravala/DirectSum.jl" alt="GitHub release (latest SemVer)"/></a> <a href="https://github.com/chakravala/DirectSum.jl/commits"><img src="https://img.shields.io/github/commits-since/chakravala/DirectSum.jl/latest?label=new%20commits" alt="GitHub commits since latest release"/></a> <a href="https://travis-ci.org/chakravala/DirectSum.jl"><img src="https://travis-ci.org/chakravala/DirectSum.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/chakravala/directsum-jl"><img src="https://ci.appveyor.com/api/projects/status/ipaggdeq2f1509pl?svg=true" alt="Build status"/></a></p><p>The <em>DirectSum.jl</em> package is a work in progress providing the necessary tools to work with an arbitrary <code>Manifold</code> specified by an encoding. Due to the parametric type system for the generating <code>TensorBundle</code>, the Julia compiler can fully preallocate and often cache values efficiently ahead of run-time. Although intended for use with the <em>Grassmann.jl</em> package, <code>DirectSum</code> can be used independently.</p><p>Let <span>$M = T^\mu V$</span> be a <code>TensorBundle{n}&lt;:Manifold{n}</code> of rank <span>$n$</span>,</p><div>\[T^\mu V = (n,\mathbb P,g,\nu,\mu), \qquad \mathbb P \subseteq\langle v_\infty,v_\emptyset\rangle, \qquad g :V\times V\rightarrow\mathbb K\]</div><p>The type <code>TensorBundle{n,ℙ,g,ν,μ}</code> uses <em>byte-encoded</em> data available at pre-compilation, where <span>$\mathbb P$</span> specifies the basis for up and down projection, <span>$g$</span> is a bilinear form that specifies the metric of the space, and <span>$\mu$</span> is an integer specifying the order of the tangent bundle (i.e. multiplicity limit of Leibniz-Taylor monomials). Lastly, <span>$\nu$</span> is the number of tangent variables. The dual space functor <span>$&#39;$</span> is an involution which toggles a dual vector space with inverted signature with property <span>$V&#39; = \text{Hom}(V,\mathbb K)$</span> and having <code>SubManifold</code> generators</p><div>\[\langle v_1,\dots,v_{n-\nu},\partial_1,\dots,\partial_\nu\rangle=M\leftrightarrow M&#39; = \langle w_1,\dots,w_{n-\nu},\epsilon_1,\dots,\epsilon_\nu\rangle\]</div><p>where <span>$v_i,w_i$</span> are a basis for the vectors and covectors, while <span>$\partial_j,\epsilon_j$</span> are a basis for differential operators and tensor fields.</p><p>The metric signature of the <code>SubManifold{V,1}</code> elements of a vector space <span>$V$</span> can be specified with the <code>V&quot;...&quot;</code> constructor by using <span>$+$</span> and <span>$-$</span> to specify whether the <code>SubManifold{V,1}</code> element of the corresponding index squares to <span>$+1$</span> or <span>$-1$</span>. For example, <code>S&quot;+++&quot;</code> constructs a positive definite 3-dimensional <code>TensorBundle</code>.</p><pre><code class="language-julia-repl">julia&gt; ℝ^3 == V&quot;+++&quot; == Manifold(3)
true</code></pre><p>It is also possible to specify an arbitrary <code>DiagonalForm</code> having numerical values for the basis with degeneracy <code>D&quot;1,1,1,0&quot;</code>, although the <code>Signature</code> format has a more compact representation. Further development will result in more metric types.</p><p>Declaring an additional plane at infinity is done by specifying it in the string constructor with <span>$\infty$</span> at the first index (i.e. Riemann sphere <code>S&quot;∞+++&quot;</code>). The hyperbolic geometry can be declared by <span>$\emptyset$</span> subsequently (i.e. Minkowski spacetime <code>S&quot;∅+++&quot;</code>). Additionally, the <em>null-basis</em> based on the projective split for confromal geometric algebra would be specified with <code>∞∅</code> initially (i.e. 5D CGA <code>S&quot;∞∅+++&quot;</code>). These two declared basis elements are interpreted in the type system.</p><p>The index number <span>$n$</span> of the <code>TensorBundle</code> corresponds to the total number of generator elements. However, even though <code>V&quot;∞∅+++&quot;</code> is of type <code>TensorBundle{5,3}</code> with <span>$5$</span> generator elements, it can be internally recognized in the direct sum algebra as being an embedding of a 3-index <code>TensorBundle{3,0}</code> with additional encoding of the null-basis (origin and point at infinity) in the parameter <span>$\mathbb P$</span> of the <code>TensorBundle{n,ℙ}</code> type.</p><p>The <code>tangent</code> map takes <span>$V$</span> to its tangent space and can be applied repeatedly for higher orders, such that <code>tangent(V,μ,ν)</code> can be used to specify <span>$\mu$</span> and <span>$\nu$</span>.</p><pre><code class="language-julia-repl">julia&gt; V = tangent(ℝ^3)
T¹⟨+++₁⟩

julia&gt; tangent(V&#39;)
T²⟨----¹⟩&#39;

julia&gt; V⊕V&#39;
T¹⟨+++---₁¹⟩*</code></pre><p>The direct sum operator <span>$\oplus$</span> can be used to join spaces (alternatively <span>$+$</span>), and the dual space functor <span>$&#39;$</span> is an involution which toggles a dual vector space with inverted signature.</p><pre><code class="language-julia-repl">julia&gt; V = ℝ&#39;⊕ℝ^3
⟨-+++⟩

julia&gt; V&#39;
⟨+---⟩&#39;

julia&gt; W = V⊕V&#39;
⟨-++++---⟩*</code></pre><p>The direct sum of a <code>TensorBundle</code> and its dual <span>$V\oplus V&#39;$</span> represents the full mother space <span>$V*$</span>.</p><pre><code class="language-julia-repl">julia&gt; collect(V) # all SubManifold vector basis elements
DirectSum.Basis{⟨-+++⟩,16}(⟨____⟩, ⟨-___⟩, ⟨_+__⟩, ⟨__+_⟩, ⟨___+⟩, ⟨-+__⟩, ⟨-_+_⟩, ⟨-__+⟩, ⟨_++_⟩, ⟨_+_+⟩, ⟨__++⟩, ⟨-++_⟩, ⟨-+_+⟩, ⟨-_++⟩, ⟨_+++⟩, ⟨-+++⟩)

julia&gt; collect(SubManifold(V&#39;)) # all covector basis elements
DirectSum.Basis{⟨+---⟩&#39;,16}(w, w¹, w², w³, w⁴, w¹², w¹³, w¹⁴, w²³, w²⁴, w³⁴, w¹²³, w¹²⁴, w¹³⁴, w²³⁴, w¹²³⁴)

julia&gt; collect(SubManifold(W)) # all mixed basis elements
DirectSum.Basis{⟨-++++---⟩*,256}(v, v₁, v₂, v₃, v₄, w¹, w², w³, w⁴, v₁₂, v₁₃, v₁₄, v₁w¹, v₁w², v₁w³, v₁w⁴, v₂₃, v₂₄, v₂w¹, v₂w², v₂w³, v₂w⁴, v₃₄, v₃w¹, v₃w², v₃w³, v₃w⁴, v₄w¹, v₄w², v₄w³, v₄w⁴, w¹², w¹³, w¹⁴, w²³, w²⁴, w³⁴, v₁₂₃, v₁₂₄, v₁₂w¹, v₁₂w², v₁₂w³, v₁₂w⁴, v₁₃₄, v₁₃w¹, v₁₃w², v₁₃w³, v₁₃w⁴, v₁₄w¹, v₁₄w², v₁₄w³, v₁₄w⁴, v₁w¹², v₁w¹³, v₁w¹⁴, v₁w²³, v₁w²⁴, v₁w³⁴, v₂₃₄, v₂₃w¹, v₂₃w², v₂₃w³, v₂₃w⁴, v₂₄w¹, v₂₄w², v₂₄w³, v₂₄w⁴, v₂w¹², v₂w¹³, v₂w¹⁴, v₂w²³, v₂w²⁴, v₂w³⁴, v₃₄w¹, v₃₄w², v₃₄w³, v₃₄w⁴, v₃w¹², v₃w¹³, v₃w¹⁴, v₃w²³, v₃w²⁴, v₃w³⁴, v₄w¹², v₄w¹³, v₄w¹⁴, v₄w²³, v₄w²⁴, v₄w³⁴, w¹²³, w¹²⁴, w¹³⁴, w²³⁴, v₁₂₃₄, v₁₂₃w¹, v₁₂₃w², v₁₂₃w³, v₁₂₃w⁴, v₁₂₄w¹, v₁₂₄w², v₁₂₄w³, v₁₂₄w⁴, v₁₂w¹², v₁₂w¹³, v₁₂w¹⁴, v₁₂w²³, v₁₂w²⁴, v₁₂w³⁴, v₁₃₄w¹, v₁₃₄w², v₁₃₄w³, v₁₃₄w⁴, v₁₃w¹², v₁₃w¹³, v₁₃w¹⁴, v₁₃w²³, v₁₃w²⁴, v₁₃w³⁴, v₁₄w¹², v₁₄w¹³, v₁₄w¹⁴, v₁₄w²³, v₁₄w²⁴, v₁₄w³⁴, v₁w¹²³, v₁w¹²⁴, v₁w¹³⁴, v₁w²³⁴, v₂₃₄w¹, v₂₃₄w², v₂₃₄w³, v₂₃₄w⁴, v₂₃w¹², v₂₃w¹³, v₂₃w¹⁴, v₂₃w²³, v₂₃w²⁴, v₂₃w³⁴, v₂₄w¹², v₂₄w¹³, v₂₄w¹⁴, v₂₄w²³, v₂₄w²⁴, v₂₄w³⁴, v₂w¹²³, v₂w¹²⁴, v₂w¹³⁴, v₂w²³⁴, v₃₄w¹², v₃₄w¹³, v₃₄w¹⁴, v₃₄w²³, v₃₄w²⁴, v₃₄w³⁴, v₃w¹²³, v₃w¹²⁴, v₃w¹³⁴, v₃w²³⁴, v₄w¹²³, v₄w¹²⁴, v₄w¹³⁴, v₄w²³⁴, w¹²³⁴, v₁₂₃₄w¹, v₁₂₃₄w², v₁₂₃₄w³, v₁₂₃₄w⁴, v₁₂₃w¹², v₁₂₃w¹³, v₁₂₃w¹⁴, v₁₂₃w²³, v₁₂₃w²⁴, v₁₂₃w³⁴, v₁₂₄w¹², v₁₂₄w¹³, v₁₂₄w¹⁴, v₁₂₄w²³, v₁₂₄w²⁴, v₁₂₄w³⁴, v₁₂w¹²³, v₁₂w¹²⁴, v₁₂w¹³⁴, v₁₂w²³⁴, v₁₃₄w¹², v₁₃₄w¹³, v₁₃₄w¹⁴, v₁₃₄w²³, v₁₃₄w²⁴, v₁₃₄w³⁴, v₁₃w¹²³, v₁₃w¹²⁴, v₁₃w¹³⁴, v₁₃w²³⁴, v₁₄w¹²³, v₁₄w¹²⁴, v₁₄w¹³⁴, v₁₄w²³⁴, v₁w¹²³⁴, v₂₃₄w¹², v₂₃₄w¹³, v₂₃₄w¹⁴, v₂₃₄w²³, v₂₃₄w²⁴, v₂₃₄w³⁴, v₂₃w¹²³, v₂₃w¹²⁴, v₂₃w¹³⁴, v₂₃w²³⁴, v₂₄w¹²³, v₂₄w¹²⁴, v₂₄w¹³⁴, v₂₄w²³⁴, v₂w¹²³⁴, v₃₄w¹²³, v₃₄w¹²⁴, v₃₄w¹³⁴, v₃₄w²³⁴, v₃w¹²³⁴, v₄w¹²³⁴, v₁₂₃₄w¹², v₁₂₃₄w¹³, v₁₂₃₄w¹⁴, v₁₂₃₄w²³, v₁₂₃₄w²⁴, v₁₂₃₄w³⁴, v₁₂₃w¹²³, v₁₂₃w¹²⁴, v₁₂₃w¹³⁴, v₁₂₃w²³⁴, v₁₂₄w¹²³, v₁₂₄w¹²⁴, v₁₂₄w¹³⁴, v₁₂₄w²³⁴, v₁₂w¹²³⁴, v₁₃₄w¹²³, v₁₃₄w¹²⁴, v₁₃₄w¹³⁴, v₁₃₄w²³⁴, v₁₃w¹²³⁴, v₁₄w¹²³⁴, v₂₃₄w¹²³, v₂₃₄w¹²⁴, v₂₃₄w¹³⁴, v₂₃₄w²³⁴, v₂₃w¹²³⁴, v₂₄w¹²³⁴, v₃₄w¹²³⁴, v₁₂₃₄w¹²³, v₁₂₃₄w¹²⁴, v₁₂₃₄w¹³⁴, v₁₂₃₄w²³⁴, v₁₂₃w¹²³⁴, v₁₂₄w¹²³⁴, v₁₃₄w¹²³⁴, v₂₃₄w¹²³⁴, v₁₂₃₄w¹²³⁴)</code></pre><p>In addition to the direct-sum operation, several other operations are supported, such as <span>$\cup,\cap,\subseteq,\supseteq$</span> for set operations. Due to the design of the <code>TensorBundle</code> dispatch, these operations enable code optimizations at compile-time provided by the bit parameters.</p><pre><code class="language-julia-repl">julia&gt; ℝ⊕ℝ&#39; ⊇ Manifold(1)
true

julia&gt; ℝ ∩ ℝ&#39; == Manifold(0)
true

julia&gt; ℝ ∪ ℝ&#39; == ℝ⊕ℝ&#39;
true</code></pre><p><strong>Remark</strong>. Although some of the operations like <span>$\cup$</span> and <span>$\oplus$</span> are similar and sometimes result in the same values, the <code>union</code> and <code>⊕</code> are entirely different operations in general.</p><div>\[\bigcup T^{\mu_i}V_i = \left(|\mathbb P|+\max\{n_i-|\mathbb P_i|\}_i,\, \bigcup \mathbb P_i,\, \cup g_i,\, \max\{\mu_i\}_i\right)\]</div><div>\[\bigoplus T^{\mu_i}V_i = \left(|\mathbb P|+\sum (n_i-|\mathbb P_i|),\, \bigcup \mathbb P_i,\, \oplus_i g_i,\,\max\{\mu_i\}_i\right)\]</div><p>Calling manifolds with sets of indices constructs the subspace representations. Given <code>M(s::Int...)</code> one can encode <code>SubManifold{length(s),M,s}</code> with induced orthogonal space <span>$Z$</span>, such that computing unions of submanifolds is done by inspecting the parameter <span>$s\in V\subseteq W$</span> and <span>$s\notin Z$</span>.</p><pre><code class="language-julia-repl">julia&gt; (ℝ^5)(3,5)
⟨__+_+⟩

julia&gt; dump(ans)
SubManifold{⟨+++++⟩,2,0x0000000000000014} ⟨__+_+⟩</code></pre><p>Here, calling a <code>Manifold</code> with a set of indices produces a <code>SubManifold</code> representation.</p><div>\[T^eV \subset T^\mu W \iff \exists Z\in\text{Vect}_{\mathbb K}(T^e(V\oplus Z) = T^{e\leq \mu}W,\,V\perp Z).\]</div><p>Operations on <code>Manifold</code> types is automatically handled at compile time.</p><p>To help provide a commonly shared and readable indexing to the user, some extended dual index print methods with full alphanumeric characters (62+2) are provided:</p><pre><code class="language-julia-repl">julia&gt; DirectSum.printindices(stdout,DirectSum.indices(UInt(2^62-1)),false,&quot;v&quot;)
v₁₂₃₄₅₆₇₈₉₀abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
julia&gt; DirectSum.printindices(stdout,DirectSum.indices(UInt(2^62-1)),false,&quot;w&quot;)
w¹²³⁴⁵⁶⁷⁸⁹⁰ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</code></pre><p>An application of this is in the <code>Grasmann</code> package, where dual indexing is used.</p><p>More information about <code>DirectSum</code> is available  at <a href="https://github.com/chakravala/DirectSum.jl">https://github.com/chakravala/DirectSum.jl</a></p><h2 id="Approaching-dimensions-with-SparseBasis-and-ExtendedBasis"><a class="docs-heading-anchor" href="#Approaching-dimensions-with-SparseBasis-and-ExtendedBasis">Approaching ∞ dimensions with <code>SparseBasis</code> and <code>ExtendedBasis</code></a><a id="Approaching-dimensions-with-SparseBasis-and-ExtendedBasis-1"></a><a class="docs-heading-anchor-permalink" href="#Approaching-dimensions-with-SparseBasis-and-ExtendedBasis" title="Permalink"></a></h2><p>In order to work with a <code>TensorAlgebra{V}</code>, it is necessary for some computations to be cached. This is usually done automatically when accessed.</p><pre><code class="language-julia">julia&gt; Λ(7) ⊕ Λ(7)&#39;
DirectSum.SparseBasis{⟨+++++++-------⟩*,16384}(v, ..., v₁₂₃₄₅₆₇w¹²³⁴⁵⁶⁷)</code></pre><p>One way of declaring the cache for all 3 combinations of a <code>TensorBundle{N}</code> and its dual is to ask for the sum <code>Λ(V) + Λ(V)&#39;</code>, which is equivalent to <code>Λ(V⊕V&#39;)</code>, but this does not initialize the cache of all 3 combinations unlike the former.</p><p>Staging of precompilation and caching is designed so that a user can smoothly transition between very high dimensional and low dimensional algebras in a single session, with varying levels of extra caching and optimizations. The parametric type formalism in <code>Grassmann</code> is highly expressive and enables pre-allocation of geometric algebra computations involving specific sparse subalgebras, including the representation of rotational groups.</p><p>It is possible to reach <code>Simplex</code> elements with up to <span>$N=62$</span> vertices from a <code>TensorAlgebra</code> having higher maximum dimensions than supported by Julia natively.</p><pre><code class="language-julia-repl">julia&gt; Λ(62)
DirectSum.ExtendedBasis{⟨++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++⟩,4611686018427387904}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ)

julia&gt; Λ(62).v32a87Ng
-1v₂₃₇₈agN</code></pre><p>The 62 indices require full alpha-numeric labeling with lower-case and capital letters. This now allows you to reach up to <span>$4,611,686,018,427,387,904$</span> dimensions with Julia <code>using Grassmann</code>. Then the volume element is</p><pre><code class="language-none">v₁₂₃₄₅₆₇₈₉₀abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre><p>Full <code>MultiVector</code> allocations are only possible for <span>$N\leq22$</span>, but sparse operations are also available at higher dimensions. While <code>DirectSum.Basis{V}</code> is a container for the <code>TensorAlgebra</code> generators of <span>$V$</span>, the <code>Basis</code> is only cached for <span>$N\leq8$</span>. For the range of dimensions <span>$8&lt;N\leq22$</span>, the <code>SparseBasis</code> type is used.</p><pre><code class="language-julia">julia&gt; Λ(22)
DirectSum.SparseBasis{⟨++++++++++++++++++++++⟩,4194304}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijkl)</code></pre><p>This is the largest <code>SparseBasis</code> that can be generated with Julia, due to array size limitations.</p><p>To reach higher dimensions with <span>$N&gt;22$</span>, the <code>DirectSum.ExtendedBasis</code> type is used. It is suficient to work with a 64-bit representation (which is the default). And it turns out that with 62 standard keyboard characters, this fits.</p><pre><code class="language-julia-repl">julia&gt; V = ℝ^22
⟨++++++++++++++++++++++⟩

julia&gt; Λ(V+V&#39;)
DirectSum.ExtendedBasis{⟨++++++++++++++++++++++----------------------⟩*,17592186044416}(v, ..., v₁₂₃₄₅₆₇₈₉₀abcdefghijklw¹²³⁴⁵⁶⁷⁸⁹⁰ABCDEFGHIJKL)</code></pre><p>At 22 dimensions and lower there is better caching, with further extra caching for 8 dimensions or less. Thus, the largest Hilbert space that is fully reachable has 4,194,304 dimensions, but we can still reach out to 4,611,686,018,427,387,904 dimensions with the <code>ExtendedBasis</code> built in. It is still feasible to extend to a further super-extended 128-bit representation using the <code>UInt128</code> type (but this will require further modifications of internals and helper functions. To reach into infinity even further, it is theoretically possible to construct ultra-extensions also using dictionaries. Full <code>MultiVector</code> elements are not representable when <code>ExtendedBasis</code> is used, but the performance of the <code>Basis</code> and sparse elements should be just as fast as for lower dimensions for the current <code>SubAlgebra</code> and <code>TensorAlgebra</code> types. The sparse representations are a work in progress to be improved with time.</p><h2 id="Interoperability-for-TensorAlgebra{V}"><a class="docs-heading-anchor" href="#Interoperability-for-TensorAlgebra{V}">Interoperability for <code>TensorAlgebra{V}</code></a><a id="Interoperability-for-TensorAlgebra{V}-1"></a><a class="docs-heading-anchor-permalink" href="#Interoperability-for-TensorAlgebra{V}" title="Permalink"></a></h2><p><a href="https://zenodo.org/badge/latestdoi/169811826"><img src="https://zenodo.org/badge/169811826.svg" alt="DOI"/></a> <a href="https://github.com/chakravala/AbstractTensors.jl/releases"><img src="https://img.shields.io/github/v/release/chakravala/AbstractTensors.jl" alt="GitHub release (latest SemVer)"/></a> <a href="https://github.com/chakravala/AbstractTensors.jl/commits"><img src="https://img.shields.io/github/commits-since/chakravala/AbstractTensors.jl/latest?label=new%20commits" alt="GitHub commits since latest release"/></a> <a href="https://travis-ci.org/chakravala/AbstractTensors.jl"><img src="https://travis-ci.org/chakravala/AbstractTensors.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://ci.appveyor.com/project/chakravala/abstracttensors-jl"><img src="https://ci.appveyor.com/api/projects/status/yey8huk505h4b81u?svg=true" alt="Build status"/></a></p><p>The <code>AbstractTensors</code> package is intended for universal interoperability of the abstract <code>TensorAlgebra</code> type system. All <code>TensorAlgebra{V}</code> subtypes have type parameter <span>$V$</span>, used to store a <code>TensorBundle</code> value obtained from <em>DirectSum.jl</em>. By itself, this package does not impose any specifications or structure on the <code>TensorAlgebra{V}</code> subtypes and elements, aside from requiring <span>$V$</span> to be a <code>TensorBundle</code>. This means that different packages can create tensor types having a common underlying <code>TensorBundle</code> structure. For example, this is mainly used in <em>Grassmann.jl</em> to define various <code>SubAlgebra</code>, <code>TensorTerm</code> and <code>TensorMixed</code> types, each with subtypes. Externalizing the abstract type helps extend the dispatch to other packages.</p><p>The key to making the whole interoperability work is that each <code>TensorAlgebra</code> subtype shares a <code>TensorBundle</code> parameter (with all <code>isbitstype</code> parameters), which contains all the info needed at compile time to make decisions about conversions. So other packages need only use the vector space information to decide on how to convert based on the implementation of a type. If external methods are needed, they can be loaded by <code>Requires</code> when making a separate package with <code>TensorAlgebra</code> interoperability.</p><p>Since <code>TensorBundle</code> choices are fundamental to <code>TensorAlgebra</code> operations, the universal interoperability between <code>TensorAlgebra{V}</code> elements with different associated <code>TensorBundle</code> choices is naturally realized by applying the <code>union</code> morphism to operations, e.g. <span>$\bigwedge :\Lambda^{p_1}V_1\times\dots\times\Lambda^{p_g}V_g \rightarrow \Lambda^{\sum_kp_k}\bigcup_k V_k$</span>. Some of the method names like <span>$+,-,*,\otimes,\circledast,\odot,\boxtimes,\star$</span> for <code>TensorAlgebra</code> elements are shared across different packages, with interoperability.</p><pre><code class="language-julia">function op(::TensorAlgebra{V},::TensorAlgebra{V}) where V
    # well defined operations if V is shared
end # but what if V ≠ W in the input types?

function op(a::TensorAlgebra{V},b::TensorAlgebra{W}) where {V,W}
    VW = V ∪ W        # VectorSpace type union
    op(VW(a),VW(b))   # makes call well-defined
end # this option is automatic with interop(a,b)

# alternatively for evaluation of forms, VW(a)(VW(b))</code></pre><p>Suppose we are dealing with a new subtype in another project, such as</p><pre><code class="language-julia">using AbstractTensors, DirectSum
struct SpecialTensor{V} &lt;: TensorAlgebra{V} end
a = SpecialTensor{ℝ}()
b = SpecialTensor{ℝ&#39;}()</code></pre><p>To define additional specialized interoperability for further methods, it is necessary to define dispatch that catches well-defined operations for equal <code>TensorBundle</code> choices and a fallback method for interoperability, along with a <code>TensorBundle</code> morphism:</p><pre><code class="language-julia">(W::Signature)(s::SpecialTensor{V}) where V = SpecialTensor{W}() # conversions
op(a::SpecialTensor{V},b::SpecialTensor{V}) where V = a # do some kind of operation
op(a::TensorAlgebra{V},b::TensorAlgebra{W}) where {V,W} = interop(op,a,b) # compat</code></pre><p>which should satisfy (using the <span>$\cup$</span> operation as defined in <code>DirectSum</code>)</p><pre><code class="language-julia-repl">julia&gt; op(a,b) |&gt; Manifold == Manifold(a) ∪ Manifold(b)
true</code></pre><p>Thus, interoperability is simply a matter of defining one additional fallback method for the operation and also a new form <code>TensorBundle</code> compatibility morphism.</p><p>Additionally, a universal unit volume element can be specified in terms of <code>LinearAlgebra.UniformScaling</code>, which is independent of <span>$V$</span> and has its interpretation only instantiated by the context of the <code>TensorAlgebra{V}</code> element being operated on. The universal interoperability of <code>LinearAlgebra.UniformScaling</code> as a pseudoscalar element which takes on the <code>TensorBundle</code> form of any other <code>TensorAlgebra</code> element is handled globally. This enables the usage of <span>$I$</span> from <code>LinearAlgebra</code> as a universal pseudoscalar element.</p><pre><code class="language-julia">(W::Signature)(s::UniformScaling) = ones(ndims(W)) # interpret a unit pseudoscalar
op(a::TensorAlgebra{V},b::UniformScaling) where V = op(a,V(b)) # right pseudoscalar
op(a::UniformScaling,b::TensorAlgebra{V}) where V = op(V(a),b) # left pseudoscalar</code></pre><p>Utility methods such as <code>scalar, involute, norm, norm2, unit, even, odd</code> are also defined.</p><p>To support a generalized interface for <code>TensorAlgebra</code> element evaluation, a similar compatibility interface is constructible.</p><pre><code class="language-julia">(a::SpecialTensor{V})(b::SpecialTensor{V}) where V = a # conversion of some form
(a::SpecialTensor{W})(b::SpecialTensor{V}) where {V,W} = interform(a,b) # compat</code></pre><p>which should satisfy (using the <span>$\cup$</span> operation as defined in <code>DirectSum</code>)</p><pre><code class="language-julia-repl">julia&gt; b(a) |&gt; Manifold == Manifold(a) ∪ Manifold(b)
true</code></pre><p>The purpose of the <code>interop</code> and <code>interform</code> methods is to help unify the interoperability of <code>TensorAlgebra</code> elements.</p><p>More information about <code>DirectSum</code> is available  at <a href="https://github.com/chakravala/AbstractTensors.jl">https://github.com/chakravala/AbstractTensors.jl</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../algebra/">Algebra »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 9 July 2020 18:21">Thursday 9 July 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
